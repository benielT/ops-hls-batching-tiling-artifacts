=================================================================================================================== source PP =====================================================================================================================/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* * The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @Test application for fpga batched temporal blocked jacobian 2D
  * @author Beniel Thileepan
  */

// standard headers
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

extern const unsigned short mem_vector_factor;

// OPS header file

//#define VERIFICATION
// #define OPS_CPP_API

// #define OPS_FPGA
// #define PROFILE
// #define POWER_PROFILE
static inline float myfun() {
  return static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
}
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @file
  * @brief OPS core library function declarations
  * @author Gihan Mudalige
  * @details function declarations header file for the core library functions
  * utilized by all OPS backends
  */




// Needed for size_t
#include <string>
#include <map>
#include <cstring>





#include <complex>

/** default byte alignment for allocations made by OPS */




/** Maximum internal halo depth over MPI -
 * extend if you get a runtime error about this being too small
 */





/**
 * maximum number of spatial dimensions supported.
 * Can reduce to save on size of metadata
 */






/*
* essential typedefs
*/












typedef std::complex<double> complexd;
typedef std::complex<float> complexf;

/*
 * * zero constants
 * */




































/**
 * type for memory space flags - 1 for host, 2 for device
 */
typedef int ops_memspace;



typedef int ops_access;   // holds OP_READ, OP_WRITE, OP_RW, OP_INC, OP_MIN,
                          // OP_MAX
typedef int ops_arg_type; // holds OP_ARG_GBL, OP_ARG_DAT


/*
* Forward declarations of structures
*/
class OPS_instance;
class ops_block_core;
class ops_dat_core;
struct ops_reduction_core;
struct ops_arg;


/** Storage for OPS blocks */
class ops_block_core {
public:
  int index;        /**< index */
  int dims;         /**< dimension of block, 2D,3D .. etc*/
  char const *name; /**< name of block */
  OPS_instance *instance; /**<< pointer the the OPS_instance*/
























































};

typedef ops_block_core *ops_block;

/** Storage for OPS reduction handles */
struct ops_reduction_core {
  char *data;       /**< The data */
  int size;         /**< size of data in bytes */
  int initialized;  /**< flag indicating whether data has been initialized */
  int index;        /**< unique identifier */
  ops_access acc;   /**< Type of reduction it was used for last time */
  char *type; /**< Type */
  char *name; /**< Name */
  OPS_instance *instance;













};

typedef ops_reduction_core *ops_reduction;


class ops_stencil_core;

/** Storage for OPS datasets */
class ops_dat_core {
  public:
  int index;             /**< index */
  ops_block block;       /**< block on which data is defined */
  int dim;               /**< number of elements per grid point */
  int type_size;         /**< bytes per primitive = elem_size/dim */
  int elem_size;         /**< number of bytes per grid point */
  int size[5]; /**< size of the array in each block dimension --
                              including halo */
  int base[5]; /**< base offset to 0,0,... from the start of each
                              dimension */
  int d_m[5];  /**< halo depth in each dimension, negative direction
                          *   (at 0 end) */
  int d_p[5];  /**< halo depth in each dimension, positive direction
                          *   (at size end) */
  int x_pad;             /**< padding in x-dimension for allocating aligned memory */
  char *data;            /**< data on host */
  char *data_d;          /**< data on device */
  char const *name;      /**< name of dataset */
  char const *type;      /**< datatype */
  int dirty_hd;          /**< flag to indicate dirty status on host and device*/
  int locked_hd;         /**< flag to indicate that the user has obtained a raw data pointer,
                          *   and whether the raw pointer is held on the host or device */
  int user_managed;      /**< indicates whether the user is managing memory */
  int is_hdf5;           /**< indicates whether the data is to read from an
                          *   hdf5 file */
  char const *hdf5_file; /**< name of hdf5 file from which this dataset was
                          *   read */
  int e_dat;             /**< flag to indicate if this is an edge dat */
  size_t mem;              /**< memory in bytes allocated to this dat (under MPI,
                          *   this will be memory held on a single MPI proc) */
  size_t base_offset;      /**< computed quantity, giving offset in bytes to the
                          *   base index */
  int stride[5];/**< stride[*] > 1 if this dat is a coarse dat under
                           *   multi-grid*/


  // Default constructor zeros out all data in the struct
  ops_dat_core() { memset(this, 0, sizeof(ops_dat_core)); }
  ~ops_dat_core();









































































































































































};

typedef ops_dat_core *ops_dat;

/** Storage for OPS stencils */
class ops_stencil_core {
public:
  int index;        /**< index */
  int dims;         /**< dimensionality of the stencil */
  int points;       /**< number of stencil elements */
  char const *name; /**< name of pointer */
  int *stencil;     /**< elements in the stencil */
  int *stride;      /**< stride of the stencil */
  int *mgrid_stride;/**< stride of the stencil under multi_grid */
  int type;         /**< 0 for regular, 1 for prolongate, 2 for restrict */
};

typedef ops_stencil_core *ops_stencil;

/** Storage for OPS parallel loop arguments */
struct ops_arg {
  ops_dat dat;          /**< dataset */
  ops_stencil stencil;  /**< the stencil */
  int dim;              /**< dimension of data */
  int elem_size;        /**< #of bytes per primitive element */
  char *data;           /**< data on host */
  char *data_d;         /**< data on device (for CUDA)*/
  ops_access acc;       /**< access type */
  ops_arg_type argtype; /**< arg type */
  int opt;              /**< flag to indicate whether this is an optional arg,
                         *   0 - optional, 1 - not optional */
};

/** Storage for OPS halos */
struct ops_halo_core {
  ops_dat from;                   /**< dataset from which the halo is read */
  ops_dat to;                     /**< dataset to which the halo is written */
  int iter_size[5];     /**< size of halo region */
  int from_base[5];     /**< start position to copy from */
  int to_base[5];       /**< start position to copy to */
  int from_dir[5];      /**< copy from orientation */
  int to_dir[5];        /**< size to orientation */
  int index;                      /**< index of halo */
};

typedef ops_halo_core *ops_halo;

/** Storage for OPS halo groups */
typedef struct {
  int nhalos;                     /**< number of halos */
  ops_halo *halos;                /**< list of halos */
  int index;                      /**< index of halo group */
  OPS_instance *instance;








} ops_halo_group_core;

typedef ops_halo_group_core *ops_halo_group;

/*
* min / max definitions
*/
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @file
 * @brief OPS internal types and function declarations
 * @author Istvan Reguly
 * @details this header contains type and function declarations needed by ops_lib_core.h
 */




#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <cstring>
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)queue.h	8.5 (Berkeley) 8/20/94
 */




/*
 * This file defines five types of data structures: singly-linked lists,
 * lists, simple queues, tail queues, and circular queues.
 *
 * A singly-linked list is headed by a single forward pointer. The
 * elements are singly linked for minimum space and pointer manipulation
 * overhead at the expense of O(n) removal for arbitrary elements. New
 * elements can be added to the list after an existing element or at the
 * head of the list.  Elements being removed from the head of the list
 * should use the explicit macro for this purpose for optimum
 * efficiency. A singly-linked list may only be traversed in the forward
 * direction.  Singly-linked lists are ideal for applications with large
 * datasets and few or no removals or for implementing a LIFO queue.
 *
 * A list is headed by a single forward pointer (or an array of forward
 * pointers for a hash table header). The elements are doubly linked
 * so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before
 * or after an existing element or at the head of the list. A list
 * may only be traversed in the forward direction.
 *
 * A simple queue is headed by a pair of pointers, one the head of the
 * list and the other to the tail of the list. The elements are singly
 * linked to save space, so elements can only be removed from the
 * head of the list. New elements can be added to the list after
 * an existing element, at the head of the list, or at the end of the
 * list. A simple queue may only be traversed in the forward direction.
 *
 * A tail queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or
 * after an existing element, at the head of the list, or at the end of
 * the list. A tail queue may be traversed in either direction.
 *
 * A circle queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or after
 * an existing element, at the head of the list, or at the end of the list.
 * A circle queue may be traversed in either direction, but has a more
 * complex end of list detection.
 *
 * For details on the use of these macros, see the queue(3) manual page.
 */

/*
 * List definitions.
 */














/*
 * List functions.
 */






































/*
 * List access methods.
 */





/*
 * Singly-linked List definitions.
 */













/*
 * Singly-linked List functions.
 */


































/*
 * Singly-linked List access methods.
 */





/*
 * Singly-linked Tail queue declarations.
 */














/*
 * Singly-linked Tail queue functions.
 */






















































/*
 * Singly-linked Tail queue access methods.
 */





/*
 * Simple queue definitions.
 */














/*
 * Simple queue functions.
 */














































/*
 * Simple queue access methods.
 */





/*
 * Tail queue definitions.
 */

















/*
 * Tail queue functions.
 */



































































/*
 * Tail queue access methods.
 */










/*
 * Circular queue definitions.
 */















/*
 * Circular queue functions.
 */




































































/*
 * Circular queue access methods.
 */
#include <complex>
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* * The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles and AUTHORS ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles and AUTHORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @file
 *  @brief Header file for the utility functions used in op_util.c
 *  @author Gihan R. Mudalige, (Started 23-08-2013)
 */

void *xmalloc(size_t size);

void *xrealloc(void *ptr, size_t size);

void* xcalloc (size_t number, size_t size);

//int min(int array[], int size);

int binary_search(int a[], int value, int low, int high);

int linear_search(int a[], int value, int low, int high);

void quickSort(int arr[], int left, int right);

int removeDups(int a[], int array_size);

int file_exist(char const *filename);

inline int mult2(int *size, int dim) {
  int result = 1;
  if (dim > 0) {
    for (int i = 0; i < dim; i++)
      result *= size[i];
  }
  return result;
}

inline int add2(int *coords, int *size, int dim) {
  int result = coords[0];
  for (int i = 1; i <= dim; i++)
    result += coords[i] * mult2(size, i);
  return result;
}

inline int address2(int ndim, int dat_size, int *start, int *size, int *stride,
                    int *off) {
  int base = 0;
  for (int i = 0; i < ndim; i++) {
    base = base + dat_size * mult2(size, i) * (start[i] * stride[i] - off[i]);
  }

  /* for 2D the code generator hard codes the following */
  // base = base + dat_size * 1       * (ps[0] * std[0] - off[0]);
  // base = base + dat_size * size[0] * (ps[1] * std[1] - off[1]);

  return base;
}

inline int off2D(int dim, int *start, int *end, int *size, int *stride) {
  int i = 0;
  int c1[2];
  int c2[2];

  for (i = 0; i <= dim; i++)
    c1[i] = start[i] + 1;
  for (i = dim + 1; i < 2; i++)
    c1[i] = start[i];

  for (i = 0; i < dim; i++)
    c2[i] = end[i];
  for (i = dim; i < 2; i++)
    c2[i] = start[i];

  for (i = 0; i < 2; i++) {
    c1[i] *= stride[i];
    c2[i] *= stride[i];
  }
  int off = add2(c1, size, dim) - add2(c2, size, dim);
  return off;
}

inline int off3D(int dim, int *start, int *end, int *size, int *stride) {
  int i = 0;
  int c1[3];
  int c2[3];

  for (i = 0; i <= dim; i++)
    c1[i] = start[i] + 1;
  for (i = dim + 1; i < 3; i++)
    c1[i] = start[i];

  for (i = 0; i < dim; i++)
    c2[i] = end[i];
  for (i = dim; i < 3; i++)
    c2[i] = start[i];

  for (i = 0; i < 3; i++) {
    c1[i] *= stride[i];
    c2[i] *= stride[i];
  }
  int off = add2(c1, size, dim) - add2(c2, size, dim);
  return off;
}


/// @brief set the local memory of a ops_dat from a buf
/// @param buf pointer to the buf which is always assumed to be in AoS layout
/// @param dat pointer to the ops_dat data
/// @param buf_size the size of the buf
/// @param dat_size
/// @param d_m
/// @param elem_size the number of bits per gird point
/// @param dat_dim the number of elements per grid point
/// e.g., for a multi_dim (d) int ops_dat elem_size=4*d
/// @param range_max_dim  the range of slab
void set_loop_slab(char *buf, char *dat, const int *buf_size,
                   const int *dat_size, const int *d_m, int elem_size,
                   int dat_dim, const int *range_max_dim);

/// @brief copy the local data of a ops_dat to a buf
/// @param buf pointer to the buf which is always assumed to be in AoS layout
/// @param dat pointer to the ops_dat data
/// @param buf_size the size of the buf
/// @param dat_size
/// @param d_m
/// @param elem_size the number of bits per gird point
/// @param dat_dim the number of elements per grid point
/// e.g., for a multi_dim (d) int ops_dat elem_size=4*d
/// @param range_max_dim  the range of slab
void fetch_loop_slab(char *buf, char *dat, const int *buf_size,
                     const int *dat_size, const int *d_m, int elem_size,
                     int dat_dim, const int *range_max_dim);

/// @brief determine the range of a ops_dat at a local rank
/// @param dat a ops_dat
/// @param global_range
/// @param local_range
void determine_local_range(const ops_dat dat, const int *global_range,
                           int *local_range);
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @brief OPS exceptions
  * @author Istvan Reguly
  * @details declarations for throwing and querying exceptions in OPS
  */




#include <stdexcept>
#include <sstream>
#include <iostream>
#include <cstring>










struct OPSException : public std::exception
{
    int code;
    const static int maxsize = 2048;
    unsigned char _data[maxsize];

    int cursize;
    int ridx;
    std::stringstream msg;

    /* The copy of the underlying string returned by stringstream::str() is a temporary
     * object that will be destructed at the end of the expression, so directly calling
     * c_str() on the result of str() (for example in auto *ptr = out.str().c_str();)
     * results in a dangling pointer.  Hence we need to get the message out of 'msg'
     * and stick it in heap memory somewhere before we return it via what(), otherwise
     * programs that catch the exception will get a dangling pointer which may or may
     * not point at a valid string.  I caught this via gtest, where I got a garbage
     * message.
     */
    mutable std::string persistentMsg;

    virtual ~OPSException() throw() {}
    OPSException(int code) : code(code), cursize(0), ridx(0) { }
    OPSException(const OPSException &ex2) {
      code = ex2.code;
      memcpy(_data, ex2._data, maxsize*sizeof(unsigned char));
      cursize = ex2.cursize;
      ridx = ex2.ridx;
      msg << ex2.msg.rdbuf();
    }

    template<class T>
    OPSException& operator<< (const T& val)
    {
       insert(val);
       return *this;
    }

    OPSException(int code, const char *val) : code(code), cursize(0), ridx(0) { *this << val; }

    void insert(const char *val)
    {
       msg << val;
    }

    template<class T>
    void insert(const T& val)
    {
       if(sizeof(T) + cursize > maxsize )
       {
          std::cerr << "Too many data items!\n";
          abort();
       }

       *(T*)(_data + cursize) = val;
       cursize += sizeof(T);

       msg << val;
    }

    virtual const char* what() const throw() {
       persistentMsg = msg.str();
       return persistentMsg.c_str();
    }

    template<class T>
       const T& data() {
          if(ridx + sizeof(T) > cursize) {
             std::cerr << "Reading too many data items!\n";
             abort();
          }
          const T& ret = *(T*)(_data + ridx);
          ridx += sizeof(T);
          return ret;
       }
 };
class OPS_instance;











typedef unsigned int uint;

typedef long long ll;
typedef unsigned long long ull;
typedef unsigned long ul;




ops_arg ops_arg_gbl_char(char *data, int dim, int size, ops_access acc);


ops_dat_core* ops_decl_dat_char(ops_block_core *, int, int *, int *, int *, int *, int *, char *,
                          int, char const *, char const *);
template <typename T> void ops_decl_const2(char const *, int, char const *, T *);
void ops_decl_const_char(OPS_instance *, int, char const *, int, char *, char const *);

void ops_reduction_result_char(ops_reduction_core *handle, int type_size, char *ptr);
/*
* run-time type-checking routines
*/
inline int type_error(const double *a, const char *type) {
  (void)a;
  return strcmp(type, "double");
}
inline int type_error(const float *a, const char *type) {
  (void)a;
  return strcmp(type, "float");
}
inline int type_error(const int *a, const char *type) {
  (void)a;
  return strcmp(type, "int");
}
inline int type_error(const uint *a, const char *type) {
  (void)a;
  return  !(strcmp(type, "uint")==0 || strcmp(type, "unsigned int")==0);
}
inline int type_error(const long *a, const char *type) {
  (void)a;
  return strcmp(type, "long");
}
inline int type_error(const short *a, const char *type) {
  (void)a;
  return strcmp(type, "short");
}
inline int type_error(const char *a, const char *type) {
  (void)a;
  return strcmp(type, "char");
}
inline int type_error(const ll *a, const char *type) {
  (void)a;
  return !(strcmp(type, "ll")==0 || strcmp(type, "long long")==0) ;
}
inline int type_error(const ul *a, const char *type) {
  (void)a;
  return !(strcmp(type, "ul")==0 || strcmp(type, "unsigned long")==0) ;
}
inline int type_error(const ull *a, const char *type) {
  (void)a;
  return !(strcmp(type, "ull")==0 || strcmp(type, "unsigned long long")==0);
}
inline int type_error(const bool *a, const char *type) {
  (void)a;
  return strcmp(type, "bool");
}
inline int type_error(const std::complex<float> *a, const char *type) {
  (void)a;
  return strcmp(type, "complexf");
}
inline int type_error(const std::complex<double> *a, const char *type) {
  (void)a;
  return strcmp(type, "complexd");
}
/*******************************************************************************
* C API
*******************************************************************************/


/**
 * This routine must be called before all other OPS routines.
 *
 * @param argc         the usual command line argument
 * @param argv         the usual command line argument
 * @param diags_level  an integer which defines the level of debugging
 *                     diagnostics and reporting to be performed.
 *                     Can be overridden with the -OPS_DIAGS= runtime argument
 *
 * Currently, higher `diags_level`s perform the following checks:
 *
 * | diags level | checks                                                      |
 * | ----------- | ----------------------------------------------------------- |
 * |  = 1        | no diagnostics, default to achieve best runtime performance.|
 * |  > 1        | print block decomposition and ops par loop timing breakdown.|
 * |  > 4        | print intra-block halo buffer allocation feedback (for OPS internal development only)                 |
 * |  > 5        | check if intra-block halo MPI sends depth match MPI receives depth (for OPS internal development only)|
 *
 */

void ops_init(const int argc, const char *const argv[], const int diags_level);

/**
 * This routine must be called last to cleanly terminate the OPS computation.
 */

void ops_exit();


void ops_set_soa(const int soa_val);

/**
 * This routine defines a structured grid block.
 *
 * @param dims  dimension of the block
 * @param name  a name used for output diagnostics
 * @return
 */

ops_block ops_decl_block(int dims, const char *name);

/**
 * This routine defines a dataset.
 *
 * The @p size allows to declare different sized data arrays on a given block.
 * @p d_m and @p d_p are depth of the "block halos" that are used to indicate
 * the offset from the edge of a block (in both the negative and positive
 * directions of each dimension).
 *
 * @tparam T
 * @param block       structured block
 * @param data_size   dimension of dataset (number of items per grid element)
 * @param block_size  size in each dimension of the block
 * @param base        base indices in each dimension of the block
 * @param d_m         padding from the face in the negative direction for each
 *                    dimension (used for block halo)
 * @param d_p         padding from the face in the positive direction for each
 *                    dimension (used for block halo)
 * @param stride
 * @param data        input data of type @p T
 * @param type        the name of type used for output diagnostics
 *                    (e.g. "double", "float")
 * @param name        a name used for output diagnostics
 * @return
 */
template <class T>
ops_dat ops_decl_dat(ops_block block, int data_size, int *block_size, int *base,
                     int *d_m, int *d_p, int *stride, T *data, char const *type,
                     char const *name) {

  if (type_error(data, type)) {
    OPSException ex(5);
    ex << "Error: incorrect type specified for dataset " << name;
    throw ex;
  }

  return ops_decl_dat_char(block, data_size, block_size, base, d_m, d_p,
                           stride, (char *)data, sizeof(T), type, name);
}

/**
 * This routine defines a dataset.
 *
 * The @p size allows to declare different sized data arrays on a given block.
 * @p d_m and @p d_p are depth of the "block halos" that are used to indicate
 * the offset from the edge of a block (in both the negative and positive
 * directions of each dimension).
 *
 * @tparam T
 * @param block       structured block
 * @param data_size   dimension of dataset (number of items per grid element)
 * @param block_size  size in each dimension of the block
 * @param base        base indices in each dimension of the block
 * @param d_m         padding from the face in the negative direction for each
 *                    dimension (used for block halo)
 * @param d_p         padding from the face in the positive direction for each
 *                    dimension (used for block halo)
 * @param data        input data of type @p T
 * @param type        the name of type used for output diagnostics
 *                    (e.g. "double", "float")
 * @param name        a name used for output diagnostics
 * @return
 */
template <class T>
ops_dat ops_decl_dat(ops_block block, int data_size, int *block_size, int *base,
                     int *d_m, int *d_p, T *data, char const *type,
                     char const *name) {

  int stride[5];
  for (int i = 0; i < 5; i++) stride[i] = 1;
  return ops_decl_dat_char(block, data_size, block_size, base, d_m, d_p,
                           stride, (char *)data, sizeof(T), type, name);
}



/**
 * Deallocates an OPS dataset
 * @param dat     dataset to deallocate
 */

void ops_free_dat(ops_dat dat);

/**
 * Makes a copy of a dataset
 * @param orig_dat the dataset to be copied
 * @return the copy
 */
ops_dat ops_dat_copy(ops_dat orig_dat);

/**
 * Makes a deep copy of the data held in source
 * @param source the dataset to be copied
 * @param target the target of the copy
 */
void ops_dat_deep_copy(ops_dat target, ops_dat orig_dat);


/**
 * Passes an accessor to the value(s) at the current grid point to the user kernel.
 *
 * The ACC<type>& reference and its () operator has to be used for accessing data
 *
 * @param dat      dataset
 * @param dim
 * @param stencil  stencil for accessing data
 * @param type     string representing the type of data held in dataset
 * @param acc      access type
 * @return
 */

ops_arg ops_arg_dat(ops_dat dat, int dim, ops_stencil stencil, char const *type,
                    ops_access acc);

/**
 * Passes an accessor to the value(s) at the current grid point to the user kernel if flag is true
 *
 * The ACC<type>& reference and its () operator has to be used for accessing data
 *
 * @param dat      dataset
 * @param dim
 * @param stencil  stencil for accessing data
 * @param type     string representing the type of data held in dataset
 * @param acc      access type
 * @param flag     indicates whether the optional argument is enabled (non-0) or not (0)
 * @return
 */

ops_arg ops_arg_dat_opt(ops_dat dat, int dim, ops_stencil stencil,
                        char const *type, ops_access acc, int flag);
/**
 * Returns an array of integers (in the user kernel) that have the index of
 * the current grid point, i.e. `idx[0]` is the index in x, `idx[1]` is
 * the index in y, etc.
 * This is a globally consistent index, so even if the block is distributed
 * across different MPI partitions, it gives you the same indexes.
 * Generally used to generate initial geometry.
 *
 * @return
 */

ops_arg ops_arg_idx();

/**
 * Passes a pointer to a variable that needs to be incremented
 * (or swapped for min/max reduction) by the user kernel.
 *
 * @param handle  an ::ops_reduction handle
 * @param dim     array dimension (according to @p type)
 * @param type    string representing the type of data held in data
 * @param acc     access type
 * @return
 */

ops_arg ops_arg_reduce(ops_reduction handle, int dim, const char *type,
                       ops_access acc);

/**
 * Passes a scalar or small array that is invariant of the iteration space.
 *
 * (not to be confused with ::ops_decl_const, which facilitates
 * global scope variables).
 *
 * @tparam T
 * @param data  data array
 * @param dim   array dimension
 * @param type  string representing the type of data held in data
 * @param acc   access type
 * @return
 */
template <class T>
ops_arg ops_arg_gbl(T *data, int dim, char const *type, ops_access acc) {
    (void)type;
  return ops_arg_gbl_char((char *)data, dim, sizeof(T), acc);
}




/**
 * This routine defines a reduction handle to be used in a parallel loop.
 *
 * @param size  size of data in bytes
 * @param type  the name of type used for output diagnostics
 *              (e.g. "double", "float")
 * @param name  name of the dat used for output diagnostics
 * @return
 */

ops_reduction ops_decl_reduction_handle(int size, const char *type,
                                        const char *name);


/**
 * This routine defines a stencil.
 *
 * @param dims     dimension of loop iteration
 * @param points   number of points in the stencil
 * @param stencil  stencil for accessing data
 * @param name     string representing the name of the stencil
 * @return
 */

ops_stencil ops_decl_stencil(int dims, int points, int *stencil,
                             char const *name);

/**
 * This routine defines a strided stencil.
 *
 * The semantics for the index of data to be accessed, for stencil point `p`,
 * in dimension `m` are defined as:
 * ```
 *    stride[m]*loop index[m] + stencil[p*dims+m]
 * ```
 * where `loop_index[m]` is the iteration index (within the user-defined
 * iteration space) in the different dimensions.
 * If, for one or more dimensions, both `stride[m]` and `stencil[p*dims+m]`
 * are zero, then one of the following must be true;
 *   - the dataset being referenced has size 1 for these dimensions
 *   - these dimensions are to be omitted and so the dataset has dimension
 *     equal to the number of remaining dimensions.
 *
 * @param dims     dimension of loop iteration
 * @param points   number of points in the stencil
 * @param stencil  stencil for accessing data
 * @param stride   stride for accessing data
 * @param name     string representing the name of the stencil
 * @return
 */

ops_stencil ops_decl_strided_stencil(int dims, int points, int *sten,
                                     int *stride, char const *name);

ops_stencil ops_decl_restrict_stencil( int dims, int points, int *sten,
                                       int *stride, char const * name);

ops_stencil ops_decl_prolong_stencil( int dims, int points, int *sten,
                                      int *stride, char const * name);

/**
 * This routine defines a halo relationship between two datasets defined on two
 * different blocks.
 *
 * A @p from_dir [1,2] and a @p to_dir [2,1] means that x in the first block
 * goes to y in the second block, and y in first block goes to x in second
 * block.
 * A negative sign indicates that the axis is flipped.
 *
 * (Simple example: a transfer from (1:2,0:99,0:99) to (-1:0,0:99,0:99) would
 * use @p iter_size = [2,100,100], @p from_base = [1,0,0],
 * @p to_base = [-1,0,0], @p from_dir = [0,1,2], @p to_dir = [0,1,2].
 * In more complex cases this allows for transfers between blocks with
 * different orientations.)
 *
 * @param from       origin dataset
 * @param to         destination dataset
 * @param iter_size  defines an iteration size
 *                   (number of indices to iterate over in each direction)
 * @param from_base  indices of starting point in @p from dataset
 * @param to_base    indices of starting point in @p to dataset
 * @param from_dir   direction of incrementing for @p from for each dimension
 *                   of @p iter_size
 * @param to_dir     direction of incrementing for @p to for each dimension
 *                   of @p iter_size
 * @return
 */
ops_halo ops_decl_halo(ops_dat from, ops_dat to, int *iter_size, int *from_base,
                       int *to_base, int *from_dir, int *to_dir);


/**
 * This routine defines a collection of halos.
 * Semantically, when an exchange is triggered for all halos
 * in a group, there is no order defined in which they are carried out.
 *
 * @param nhalos  number of halos in @p halos
 * @param halos   array of halos
 * @return
 */

ops_halo_group ops_decl_halo_group(int nhalos, ops_halo *halos);

/**
 * This routine exchanges all halos in a halo group and will block execution
 * of subsequent computations that depend on the exchanged data.
 *
 * @param group  the halo group
 */

void ops_halo_transfer(ops_halo_group group);

/**
 * This routine returns the reduced value held by a reduction handle. During lazy execution,
 * this will trigger the execution of all preceding queued operations
 *
 * @tparam T
 * @param handle  the ::ops_reduction handle
 * @param ptr     a pointer to write the results to, memory size has to match
 *                the declared
 */
template <class T> void ops_reduction_result(ops_reduction handle, T *ptr) {
  if (type_error(ptr, handle->type)) {
    OPSException ex(5);
    ex << "Error: incorrect type specified for constant " << handle->name << " in ops_reduction_result";
    throw ex;
  }
  if (!handle->initialized) {
    OPSException ex(6);
    ex << "Error: ops_reduction_result called for " << handle->name << " but the handle was not previously used in a reduction since the last ops_reduction_result call.";
    throw ex;
  }
  ops_reduction_result_char(handle, sizeof(T), (char *)ptr);
}

/**
 * This routine updates/changes the value of a constant.
 *
 * @tparam T
 * @param name  a name used to identify the constant
 * @param dim   dimension of dataset (number of items per element)
 * @param type  the name of type used for output diagnostics
 *              (e.g. "double", "float")
 * @param data  pointer to new values for constant of type @p T
 */
template <class T>
void ops_update_const(char const *name, int dim, char const *type, T *data) {
  if (type_error(data, type)) {
    OPSException ex(5);
    ex << "Error: incorrect type specified for constant " << name << " in ops_update_const";
    throw ex;
  }
  ops_decl_const2(name, dim, type, data);
}

/**
 * This routine defines a global constant: a variable in global scope.
 *
 * Global constants need to be declared upfront so that they can be correctly
 * handled for different parallelizations. For e.g. CUDA on GPUs.
 * Once defined they remain unchanged throughout the program, unless changed
 * by a call to ops_update_const().
 * @tparam T
 * @param name  a name used to identify the constant
 * @param dim   dimension of dataset (number of items per element)
 * @param type  the name of type used for output diagnostics
 *              (e.g. "double", "float")
 * @param data  pointer to input data of type @p T
 */
template <class T>
void ops_decl_const(char const *name, int dim, char const *type, T *data) {
  if (type_error(data, type)) {
    OPSException ex(5);
    ex << "Error: incorrect type specified for constant " << name << " in ops_decl_const";
    throw ex;
  }
  ops_decl_const2(name, dim, type, data);
}



/**
 * This routine simply prints a variable number of arguments on the root process;
 * it is created in place of the standard C printf() function which would
 * print the same on each MPI process.
 *
 * @param format
 * @param ...
 */

void ops_printf(const char *format, ...);

/**
 * This routine simply prints a variable number of arguments on the root process;
 * it is created is in place of the standard C printf function which would
 * print the same on each MPI process.
 *
 * @param stream
 * @param format
 * @param ...
 */

void ops_fprintf(FILE *stream, const char *format, ...);


/**
 * This routine prints out various useful bits of diagnostic info about sets,
 * mappings and datasets.
 *
 * Usually used right after an @p ops partition() call to print out the details
 * of the decomposition.
 */

void ops_diagnostic_output();

/**
 * Print OPS performance performance details to output stream.
 *
 * @param stream  output stream, use std::cout to print to standard out
 */
void ops_timing_output(std::ostream &stream);

void ops_timing_output_stdout();


/**
 * gettimeofday() based timer to start/end timing blocks of code.
 *
 *
 * @param cpu  variable to hold the CPU time at the time of invocation
 * @param et   variable to hold the elapsed time at the time of invocation
 */

void ops_timers_core(double *cpu, double *et);

void ops_timers(double *cpu, double *et);


/**
 * Write the details of an ::ops_block to a named text file.
 *
 * When used under an MPI parallelization each MPI process will write its own
 * data set separately to the text file. As such it does not use MPI I/O.
 * The data can be viewed using a simple text editor

 * @param dat        ::ops_dat to to be written
 * @param file_name  text file to write to
 */

void ops_print_dat_to_txtfile(ops_dat dat, const char *file_name);

/**
 * Makes sure OPS has downloaded data from the device
 */
void ops_get_data(ops_dat dat);

/**
 * Returns one one the root MPI process
 */

int ops_is_root();

/**
 * Triggers a multi-block partitioning across a distributed memory set of
 * processes.
 * (links to a dummy function for single node parallelizations).
 * This routine should only be called after all the ops_decl_block() and
 * ops_decl_dat() statements have been declared. Must be called before any
 * calling any parallel loops
 *
 * @param routine  string describing the partitioning method.
 *                 Currently this string is not used internally, but is simply
 *                 a place-holder to indicate different partitioning methods
 *                 in the future.
 */

void ops_partition(const char *routine);

void ops_partition_opts(const char *routine, std::map<std::string, void*>& opts);
/*******************************************************************************
* External access support
*******************************************************************************/

/**
 * This routine returns the number of chunks of the given dataset held by the
 * current process.
 *
 * @param dat  the dataset
 * @return
 */

int ops_dat_get_local_npartitions(ops_dat dat);

/**
 * This routine returns the MPI displacement and size of a given chunk of the
 * given dataset on the current process.
 *
 * @param dat   the dataset
 * @param part  the chunk index (has to be 0)
 * @param disp  an array populated with the displacement of the chunk within the
 *              "global" distributed array
 * @param size  an array populated with the spatial extents
 */

void ops_dat_get_extents(ops_dat dat, int part, int *disp, int *size);

/**
 * This routine returns the MPI displacement and size of the intersection of a
 * hyper-slab with the given dataset on the current process.
 *
 * @param dat   the dataset
 * @param part  the chunk index (has to be 0)
 * @param disp  an array populated with the displacement of the chunk within the
 *              "global" distributed array
 * @param size  an array populated with the spatial extents
 * @param slab  index ranges of the hyperslab. Ordering: {begin_0, end_0, begin_1, end_1,...}
 * @return the size in bytes of the intersection between the dataset and the slab on this process
 */

size_t ops_dat_get_slab_extents(ops_dat dat, int part, int *disp, int *size, int *slab);

/**
 * This routine returns array shape metadata corresponding to the ops_dat.
 * Any of the arguments may be NULL.
 *
 * @param data     the datasets
 * @param part     the chunk index (has to be 0)
 * @param disp     an array populated with the displacement of the chunk within the
 *                 "global" distributed array
 * @param size     an array populated with the spatial extents
 * @param stride   an array populated strides in spatial dimensions needed for
 *                 column-major indexing
 * @param d_m      an array populated with padding on the left in each dimension
 *                 note that these are negative values
 * @param d_p      an array populated with padding on the right in each dimension
 */

void ops_dat_get_raw_metadata(ops_dat dat, int part, int *disp, int *size, int *stride, int *d_m, int *d_p);

/**
 * This routine returns a pointer to the internally stored data, with MPI halo
 * regions automatically updated as required by the supplied stencil.
 * The strides required to index into the dataset are also given.
 *
 * You may have to call ops_execute before calling this to make sure all
 * computations have finished.
 *
 * @param dat      the dataset
 * @param part     the chunk index (has to be 0)
 * @param stencil  a stencil used to determine required MPI halo exchange depths
 * @param memspace when set to OPS_HOST or OPS_DEVICE, returns a pointer to data in
 *                 that memory space, otherwise must be set to 0, and returns
 *                 whether data is in the host or on the device
 *
 * @return
 */

char* ops_dat_get_raw_pointer(ops_dat dat, int part, ops_stencil stencil, ops_memspace *memspace);

/**
 * Indicates to OPS that a dataset previously accessed with
 * ops_dat_get_raw_pointer() is released by the user, and also tells OPS how it
 * was accessed.
 *
 * A single call to ops_dat_release_raw_data() releases all pointers obtained by previous calls to
 * ops_dat_get_raw_pointer() calls on the same dat. Calls to ops_dat_release_raw_data() must be separated by calls to
 * ops_dat_get_raw_pointer(), i.e. it is illegal to release raw data access multiple times without first
 * starting raw data access. The data that the user wishes keep is in the memory
 * space (buffer) indicated by the LAST call to ops_dat_get_raw_pointer().  Data in any other memory spaces
 * is discarded.
 *
 * @param dat   the dataset
 * @param part  the chunk index (has to be 0
 * @param acc   the kind of access that was used by the user
 *              (::OPS_READ if it was read only,
 *              ::OPS_WRITE if it was overwritten,
 *              ::OPS_RW if it was read and written)
 */

void ops_dat_release_raw_data(ops_dat dat, int part, ops_access acc);

/**
 * Indicates to OPS that a dataset previously accessed with
 * ops_dat_get_raw_pointer() is released by the user, and also tells OPS how it
 * was accessed.
 *
 * A single call to ops_dat_release_raw_data_memspace() releases all pointers obtained by previous calls to
 * ops_dat_get_raw_pointer() calls on the same dat. Calls to ops_dat_release_raw_data_memspace() must be separated by calls to
 * ops_dat_get_raw_pointer(), i.e. it is illegal to release raw data access multiple times without first
 * starting raw data access.
 * The *memspace argument tells OPS in which memory space the data is that the user wants to keep.
 * Data in all other memory spaces will be discarded.
 *
 * @param dat   the dataset
 * @param part  the chunk index (has to be 0
 * @param acc   the kind of access that was used by the user
 *              (::OPS_READ if it was read only,
 *              ::OPS_WRITE if it was overwritten,
 *              ::OPS_RW if it was read and written)
 * @param memspace has to be set to either OPS_HOST or OPS_DEVICE to indicate where the data was modified
 */

void ops_dat_release_raw_data_memspace(ops_dat dat, int part, ops_access acc, ops_memspace *memspace);


/**
 * This routine copies the data held by OPS to the user-specified
 * memory location, which needs to be at least as large as indicated
 * by the `sizes` parameter of ops_dat_get_extents().

 * @param dat   the dataset
 * @param part  the chunk index (has to be 0)
 * @param data  pointer to CPU memory which should be filled by OPS
 */

void ops_dat_fetch_data(ops_dat dat, int part, char *data);

/**
 * This routine copies the data held by OPS to the user-specified
 * memory location, which needs to be at least as large as indicated
 * by the `sizes` parameter of ops_dat_get_extents().

 * @param dat   the dataset
 * @param part  the chunk index (has to be 0)
 * @param data  pointer to memory which should be filled by OPS
 * @param memspace the memory space where the data pointer is
 */

void ops_dat_fetch_data_memspace(ops_dat dat, int part, char *data, ops_memspace memspace);

/**
 * This routine copies a hyperslab of the data held by OPS to the user-specified
 * memory location, which needs to be at least as large as the product of ranges
 * defined by the `range` parameter

 * @param dat   the dataset
 * @param part  the chunk index (has to be 0)
 * @param data  pointer to memory which should be filled by OPS
 * @param range index ranges of the hyperslab. Ordering: {begin_0, end_0, begin_1, end_1,...}
 * @param memspace the memory space where the data pointer is
 */

void ops_dat_fetch_data_slab_memspace(ops_dat dat, int part, char *data, int *range, ops_memspace memspace);

/**
 * This routine copies the data given by the user to the internal data structure
 * used by OPS.
 *
 * User data needs to be laid out in column-major order and strided as indicated
 * by the `sizes` parameter of ops_dat_get_extents().
 *
 * @param dat   the dataset
 * @param part  the chunk index (has to be 0)
 * @param data  pointer to CPU memory which should be copied to OPS
 */

void ops_dat_set_data(ops_dat dat, int part, char *data);

/**
 * This routine copies the data from the user-specified
 * memory location, which needs to be at least as large as indicated
 * by the `sizes` parameter of ops_dat_get_extents(), to the OPS-held
 * memory space

 * @param dat   the dataset to be filled
 * @param part  the chunk index (has to be 0)
 * @param data  pointer to memory which should be read by OPS
 * @param memspace the memory space where the data pointer is
 */

void ops_dat_set_data_memspace(ops_dat dat, int part, char *data, ops_memspace memspace);

/**
 * This routine copies to a hyperslab of the data held by OPS from the user-specified
 * memory location, which needs to be at least as large as the product of ranges
 * defined by the `range` parameter

 * @param dat   the dataset
 * @param part  the chunk index (has to be 0)
 * @param data  pointer to memory which should be read by OPS
 * @param range index ranges of the hyperslab. Ordering: {begin_0, end_0, begin_1, end_1,...}
 * @param memspace the memory space where the data pointer is
 */

void ops_dat_set_data_slab_memspace(ops_dat dat, int part, char *data, int *range, ops_memspace memspace);


/**
 * This routine returns the number of chunks of the given dataset held by all
 * processes.
 *
 * @param dat  the dataset
 * @return
 */

int ops_dat_get_global_npartitions(ops_dat dat);


/**
 * This class is an accessor to data stored in ops_dats. It is
 * only to be used in user kernels and functions called from within
 * user kernels. The user should never explicitly construct such an
 * object, these are constucted by OPS and passed by reference to
 * the user kernel.
 *
 * Data can be accessed using the overloaded () operator - with as many
 * arguments as many dimensional the dataset is (i.e. 2 in 2D). An extra
 * argument is used for datasets that have multiple values at each gridpoint.
 * Arguments are always relative offsets w.r.t. the current grid point.
 *
 */

template<typename T>
class ACC {
public:
  //////////////////////////////////////////////////
  // 1D
  /////////////////////////////////////////////////


































  //////////////////////////////////////////////////
  // 2D
  /////////////////////////////////////////////////

































  //////////////////////////////////////////////////
  // 3D
  /////////////////////////////////////////////////


  ACC(int _sizex, int _sizey, T *_ptr) : sizex(_sizex), sizey(_sizey), ptr(_ptr) {}

  ACC(int _mdim, int _sizex, int _sizey, int _sizez, T *_ptr) : sizex(_sizex), sizey(_sizey),



    mdim(_mdim),

    ptr(_ptr)
  {}

  const T& operator()(int xoff, int yoff, int zoff) const {return *(ptr + xoff + yoff*sizex + zoff*sizex*sizey);}

  T& operator()(int xoff, int yoff, int zoff) {return *(ptr + xoff + yoff*sizex + zoff*sizex*sizey);}

  const T& operator()(int d, int xoff, int yoff, int zoff) const {



    return *(ptr + d + xoff*mdim + yoff*sizex*mdim + zoff*sizex*sizey*mdim);

  }

  T& operator()(int d, int xoff, int yoff, int zoff) {



    return *(ptr + d + xoff*mdim + yoff*sizex*mdim + zoff*sizex*sizey*mdim);

  }


  //////////////////////////////////////////////////
  // 4D
  /////////////////////////////////////////////////





































  void next(int offset) {
    ptr += offset;
  }


private:

  int sizex;


  int sizey;











  int mdim;

  T *__restrict ptr;
};
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @file
 * @brief OPS internal types and function declarations
 * @author Istvan Reguly
 * @details this header contains type and function declarations
 * not needed by ops_lib_core.h, but needed by backends and generated code
 */







/*
* enum list for ops_par_loop
*/














/*
 * * zero constants
 * */

































/*
 * alignment macro based on example on page 50 of CUDA Programming Guide version
 * 3.0
 * rounds up to nearest multiple of 16 bytes
 */




// struct definition for a double linked list entry to hold an ops_dat
struct ops_dat_entry_core {
  ops_dat dat;
  struct { struct ops_dat_entry_core *tqe_next;		/* next element */ struct ops_dat_entry_core * *tqe_prev;	/* address of previous next element */}
  entries; /**< holds pointers to next and previous entries in the list*/
};

typedef struct ops_dat_entry_core ops_dat_entry;

typedef struct { struct ops_dat_entry_core *tqh_first;		/* first element */ struct ops_dat_entry_core * *tqh_last;	/* addr of last next element */	} Double_linked_list;

/** Storage for OPS block - OPS dataset associations */
struct ops_block_descriptor {
  ops_block_core *block;        /**< pointer to the block */
  Double_linked_list datasets;  /**< list of datasets associated with this block */
  int num_datasets;             /**< number of datasets */

};

/** Storage for OPS parallel loop statistics */
struct ops_kernel {
  char *name;      /**< name of kernel function */
  int count;       /**< number of times called */
  double time;     /**< total execution time */
  float transfer;  /**< bytes of data transfer (used) */
  double mpi_time; /**< time spent in MPI calls */
  //  double       mpi_gather;
  //  double       mpi_scatter;
  //  double       mpi_sendrecv;
  //  double       mpi_reduct;
};

/** Storage for OPS parallel handles */
struct ops_kernel_descriptor {
  char *name;           /**< name of kernel */
  int name_len;         /**< kernel name length */
  size_t hash;                /**< hash of loop */
  ops_arg *args;              /**< list of arguments to pass in */
  int nargs;                  /**< number of arguments */
  int index;                  /**< index of the loop */
  int dim;                    /**< number of dimensions */
  int isdevice;                 /**< flag to indicate if loop runs on device */
  int *range;                 /**< process local execution range */
  int *orig_range;            /**< original execution range */
  ops_block block;            /**< block to execute on */
  void (*func)(struct ops_kernel_descriptor *desc); /**< Function pointer to a wrapper to be called */
  void (*startup_func)(struct ops_kernel_descriptor *desc); /**< Function pointer to a wrapper to be called */
  void (*cleanup_func)(struct ops_kernel_descriptor *desc); /**< Function pointer to a wrapper to be called */

};

///
/// Struct duplicating information in MPI_Datatypes for (strided) halo access
///

typedef struct {
  int count;       ///< number of blocks
  int blocklength; ///< size of blocks
  int stride;      ///< stride between blocks
} ops_int_halo;


ops_reduction ops_decl_reduction_handle_core(OPS_instance *instance, int size, const char *type,
                                             const char *name);
void ops_execute_reduction(ops_reduction handle);

ops_arg ops_arg_reduce_core(ops_reduction handle, int dim, const char *type,
                            ops_access acc);

void ops_init_core(OPS_instance *instance, const int argc, const char *const argv[], const int diags_level);

void ops_exit_lazy(OPS_instance *instance);
void ops_exit_core(OPS_instance *instance);




ops_dat ops_decl_dat_core(ops_block block, int data_size, int *block_size,
                          int *base, int *d_m, int *d_p, int *stride, char *data,
                          int type_size, char const *type, char const *name);

ops_dat ops_decl_dat_temp_core(ops_block block, int data_size, int *block_size,
                               int *base, int *d_m, int *d_p, int *stride, char *data,
                               int type_size, char const *type,
                               char const *name);

ops_dat ops_decl_dat_mpi_char(ops_block block, int size, int *dat_size,
                              int *base, int *d_m, int *d_p, int *stride, char *data,
                              int type_size, char const *type,
                              char const *name);

void ops_decl_const_core(int dim, char const *type, int typeSize, char *data,
                         char const *name);

ops_halo ops_decl_halo_core(OPS_instance *instance, ops_dat from, ops_dat to, int *iter_size,
                            int *from_base, int *to_base, int *from_dir,
                            int *to_dir);



ops_arg ops_arg_dat_core(ops_dat dat, ops_stencil stencil, ops_access acc);
ops_arg ops_arg_gbl_core(char *data, int dim, int size, ops_access acc);


void ops_print_dat_to_txtfile_core(ops_dat dat, const char *file_name);

void ops_NaNcheck(ops_dat dat);
void ops_NaNcheck_core(ops_dat dat, char *buffer);

void ops_timing_realloc(OPS_instance *instance, int, const char *);
float ops_compute_transfer(int dims, int *start, int *end, ops_arg *arg);

void ops_register_args(OPS_instance *instance, ops_arg *args, const char *name);
int ops_stencil_check_1d(int arg_idx, int idx0, int dim0);
int ops_stencil_check_2d(int arg_idx, int idx0, int idx1, int dim0, int dim1);
int ops_stencil_check_3d(int arg_idx, int idx0, int idx1, int idx2, int dim0,
                         int dim1);

int ops_stencil_check_1d_md(int arg_idx, int idx0, int mult_d, int d);
int ops_stencil_check_2d_md(int arg_idx, int idx0, int idx1, int dim0, int dim1,
                            int mult_d, int d);
int ops_stencil_check_3d_md(int arg_idx, int idx0, int idx1, int idx2, int dim0,
                            int dim1, int mult_d, int d);

/* check if these should be placed here */

void ops_set_dirtybit_host(
    ops_arg *args, int nargs); // data updated on host .. i.e. dirty on host
void ops_set_halo_dirtybit(ops_arg *arg);

void ops_set_halo_dirtybit3(ops_arg *arg, int *iter_range);

void ops_halo_exchanges(ops_arg *args, int nargs, int *range);
void ops_halo_exchanges_datlist(ops_dat *dats, int ndats, int *depths);


void ops_set_dirtybit_device(ops_arg *args, int nargs);

void ops_H_D_exchanges_host(ops_arg *args, int nargs);

void ops_H_D_exchanges_device(ops_arg *args, int nargs);
void ops_cpHostToDevice(OPS_instance *instance, void **data_d, void **data_h, size_t size);

void ops_init_arg_idx(int *arg_idx, int ndims, ops_arg *args, int nargs);

void ops_mpi_reduce_float(ops_arg *args, float *data);
void ops_mpi_reduce_double(ops_arg *args, double *data);
void ops_mpi_reduce_int(ops_arg *args, int *data);

void ops_dat_fetch_data_host(ops_dat dat, int part, char *data);
void ops_dat_fetch_data_slab_host(ops_dat dat, int part, char *data, int *range);

void ops_dat_set_data_host(ops_dat dat, int part, char *data);
void ops_dat_set_data_slab_host(ops_dat dat, int part, char *local_buf,
                                int *local_range);

void ops_compute_moment(double t, double *first, double *second);

void ops_dump3(ops_dat dat, const char *name);

void ops_halo_copy_frombuf(ops_dat dest, char *src, int src_offset, int rx_s,
                           int rx_e, int ry_s, int ry_e, int rz_s, int rz_e,
                           int x_step, int y_step, int z_step,
                           int buf_strides_x, int buf_strides_y,
                           int buf_strides_z);
void ops_halo_copy_tobuf(char *dest, int dest_offset, ops_dat src, int rx_s,
                         int rx_e, int ry_s, int ry_e, int rz_s, int rz_e,
                         int x_step, int y_step, int z_step, int buf_strides_x,
                         int buf_strides_y, int buf_strides_z);

/* lazy execution */
void ops_enqueue_kernel(ops_kernel_descriptor *desc);

void ops_execute(OPS_instance *instance=NULL);
bool ops_get_abs_owned_range(ops_block block, int *range, int *start, int *end, int *disp);
int compute_ranges(ops_arg* args, int nargs, ops_block block, int* range, int* start, int* end, int* arg_idx);
int ops_get_proc();
int ops_num_procs();
void ops_put_data(ops_dat dat);

void create_kerneldesc_and_enque(char const *name, char const* kernel_name, ops_arg *args, int nargs, int index, int dim, int isdevice, int *range, ops_block block, void (*func)(struct ops_kernel_descriptor *desc));

/*******************************************************************************
* Memory allocation functions
*******************************************************************************/
void* ops_malloc (size_t size);
void* ops_realloc (void *ptr, size_t size);
void  ops_free (void *ptr);
void* ops_calloc (size_t num, size_t size);
void ops_init_zero(char *data, size_t bytes);
void ops_convert_layout(char *in, char *out, ops_block block, int size, int *dat_size, int *dat_size_orig, int type_size, int hybrid_layout);

//Includes for common device backends
void ops_init_device(OPS_instance *instance, const int argc, const char *const argv[], const int diags);
void ops_device_free(OPS_instance *instance, void** ptr);
void ops_device_freehost(OPS_instance *instance, void** ptr);
void ops_device_exit(OPS_instance *instance);
void ops_device_malloc(OPS_instance *instance, void** ptr, size_t bytes);
void ops_device_mallochost(OPS_instance *instance, void** ptr, size_t bytes);
void ops_device_memcpy_h2d(OPS_instance *instance, void** to, void **from, size_t size);
void ops_device_memcpy_d2h(OPS_instance *instance, void** to, void **from, size_t size);
void ops_device_memcpy_d2d(OPS_instance *instance, void** to, void **from, size_t size);
void ops_device_memset(OPS_instance *instance, void** ptr, int val, size_t size);
void ops_device_sync(OPS_instance *instance);
void ops_exit_device(OPS_instance *instance);


void _ops_init(OPS_instance *instance, const int argc, const char * const argv[], const int diags_level);
ops_block _ops_decl_block(OPS_instance *instance, int dims, const char * name);
ops_stencil _ops_decl_stencil(OPS_instance *instance, int dims, int points, int *stencil,
    char const *name);
ops_stencil _ops_decl_strided_stencil(OPS_instance *instance, int dims, int points, int *sten,
    int *stride, char const *name);
ops_stencil _ops_decl_restrict_stencil(OPS_instance *instance, int dims, int points, int *sten,
    int *stride, char const * name);
ops_stencil _ops_decl_prolong_stencil(OPS_instance *instance, int dims, int points, int *sten,
    int *stride, char const * name);
ops_halo _ops_decl_halo(OPS_instance *instance, ops_dat from, ops_dat to, int *iter_size, int *from_base,
    int *to_base, int *from_dir, int *to_dir);
ops_halo_group _ops_decl_halo_group(OPS_instance *instance, int nhalos, ops_halo *halos);
ops_reduction _ops_decl_reduction_handle(OPS_instance *instance, int size, const char *type,
                                        const char *name);
void ops_free_dat_core(ops_dat dat);
void _ops_free_dat(ops_dat dat);
void _ops_diagnostic_output(OPS_instance *instance);
void _ops_timing_output(OPS_instance *instance,std::ostream &stream);

void _ops_timing_output_stdout(OPS_instance *instance);
int _ops_is_root(OPS_instance *instance);
void _ops_partition(OPS_instance *instance, const char *routine);
void _ops_partition(OPS_instance *instance, const char *routine, std::map<std::string, void*>& opts);
void _ops_exit(OPS_instance *instance);

void ops_printf2(OPS_instance *instance, const char *format, ...);
void printf2(OPS_instance *instance, const char *format, ...);

void ops_fprintf2(std::ostream &, const char *format, ...);
void fprintf2(std::ostream &, const char *format, ...);

ops_dat ops_dat_alloc_core(ops_block block);
int ops_dat_copy_metadata_core(ops_dat target, ops_dat orig_dat);
ops_kernel_descriptor * ops_dat_deep_copy_core(ops_dat target, ops_dat orig_dat, int *range);
void ops_internal_copy_seq(ops_kernel_descriptor *desc);
void ops_internal_copy_device(ops_kernel_descriptor *desc);


void ops_upload_gbls(ops_arg* args, int nargs);

//
// wrapper functions to handle MPI global reductions
//

inline void ops_mpi_reduce(ops_arg *args, float *data) {
  ops_mpi_reduce_float(args, data);
}

inline void ops_mpi_reduce(ops_arg *args, double *data) {
  ops_mpi_reduce_double(args, data);
}

inline void ops_mpi_reduce(ops_arg *args, int *data) {
  ops_mpi_reduce_int(args, data);
}

class OPS_instance;
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* * The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @file
  * @brief OPS checkpointing library function declarations
  * @author Istvan Reguly
  * @details function declarations for checkpointing
  */




typedef enum {
  OPS_BACKUP_GATHER,
  OPS_BACKUP_LEADIN,
  OPS_BACKUP_RESTORE,
  OPS_BACKUP_BEGIN,
  OPS_BACKUP_IN_PROCESS,
  OPS_BACKUP_END,
  OPS_NONE
} ops_backup_state;
typedef enum { OPS_NOT_SAVED, OPS_SAVED, OPS_UNDECIDED } ops_checkpoint_types;

typedef enum {
    /**
     * Indicates that there are a number of parallel loops at the very beginning
     * of the simulations which should be excluded from any checkpoint;
     * mainly because they initialise datasets that do not change during the
     * main body of the execution.
     * During restore mode these loops are executed as usual.
     * An example would be the computation of the mesh geometry, which can be
     * excluded from the checkpoint if it is re-computed when recovering and
     * restoring a checkpoint.
     * The API call void ops_checkpointing_initphase_done() indicates the end
     * of this initial phase.
     */
  OPS_CHECKPOINT_INITPHASE = 1,
    /**
     * Indicates that the user manually controls the location of the checkpoint,
     * and explicitly specifies the list of ::ops_dat s to be saved.
     */
  OPS_CHECKPOINT_MANUAL_DATLIST = 2,
    /**
     * Indicates that the user manually controls the location of the checkpoint,
     * and it also enables fast-forwarding, by skipping the execution of the
     * application (even though none of the parallel loops would actually
     * execute, there may be significant work outside of those) up to the
     * checkpoint.
     */
  OPS_CHECKPOINT_FASTFW = 4,
    /**
     * Indicates that when the corresponding API function is called, the
     * checkpoint should be created.
     * Assumes the presence of the above two options as well.
     */
  OPS_CHECKPOINT_MANUAL = 8
} ops_checkpoint_options;


/**
 * Initialises the checkpointing system, has to be called after ops_partition().
 *
 * @param filename  name of the file for checkpointing.
 *                In MPI, this will automatically be postfixed with the rank ID.
 * @param interval  average time (seconds) between checkpoints
 * @param options   a combinations of flags, defined by ::ops_checkpoint_options
 * @return          `true` if the application launches in restore mode,
 *                  `false` otherwise.
 */

bool ops_checkpointing_init(const char *filename, double interval, int options);

void ops_checkpointing_initphase_done();
bool ops_checkpointing_before(ops_arg *args, int nargs, int *range,
                              int loop_id);
bool ops_checkpointing_name_before(ops_arg *args, int nargs, int *range,
                                   const char *s);
void ops_checkpointing_exit(OPS_instance *);
void ops_checkpointing_reduction(ops_reduction red);

/**
 * Call this routine at a point in the code to mark the location of a checkpoint.
 *
 * At this point, the list of datasets specified will be saved.
 * The validity of what is saved is not checked by the checkpointing algorithm
 * assuming that the user knows what data sets to be saved for full recovery.
 * This routine should be called frequently (compared to check-pointing
 * frequency) and it will trigger the creation of the checkpoint the first time
 * it is called after the timeout occurs.
 *
 * @param ndats    number of datasets to be saved
 * @param datlist  arrays of ::ops_dat handles to be saved
 */

void ops_checkpointing_manual_datlist(int ndats, ops_dat *datlist);

/**
 * Call this routine at a point in the code to mark the location of a checkpoint.
 *
 * At this point, the specified payload (e.g. iteration count, simulation time,
 * etc.) along with the necessary datasets, as determined by the checkpointing
 * algorithm will be saved.
 * This routine should be called frequently (compared to checkpointing
 * frequency), will trigger the creation of the checkpoint the first time it is
 * called after the timeout occurs.
 * In restore mode, will restore all datasets the first time it is called, and
 * returns `true` indicating that the saved payload is returned in payload.
 * Does not save reduction data.
 *
 * @param nbytes   size of the payload in bytes
 * @param payload  pointer to memory into which the payload is packed
 * @return
 */

bool ops_checkpointing_fastfw(int nbytes, char *payload);

/**
 * Combines the ops_checkpointing_manual_datlist() and
 * ops_checkpointing_fastfw() calls.
 *
 * @param ndats    number of datasets to be saved
 * @param datlist  arrays of ::ops_dat handles to be saved
 * @param nbytes   size of the payload in bytes
 * @param payload  pointer to memory into which the payload is packed
 * @return
 */

bool ops_checkpointing_manual_datlist_fastfw(int ndats, ops_dat *datlist,
                                             int nbytes, char *payload);

/**
 * With this routine it is possible to manually trigger checkpointing,
 * instead of relying on the timeout process.
 *
 * It combines the ops_checkpointing_manual_datlist() and
 * ops_checkpointing_fastfw() calls, and triggers the creation of a
 * checkpoint when called.
 *
 * @param ndats    number of datasets to be saved
 * @param datlist  arrays of ::ops_dat handles to be saved
 * @param nbytes   size of the payload in bytes
 * @param payload  pointer to memory into which the payload is packed
 * @return
 */

bool ops_checkpointing_manual_datlist_fastfw_trigger(int ndats,
                                                     ops_dat *datlist,
                                                     int nbytes, char *payload);
/*
 * Open source copyright declaration based on BSD open source template:
 * http://www.opensource.org/licenses/bsd-license.php
 *
 * This file is part of the OPS distribution.
 *
 * Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
 * the main source directory for a full list of copyright holders.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * * The name of Mike Giles may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/** @file
 * @brief  Header file for the parallel I/O functions
 * @author Gihan Mudalige (started 28-08-2015)
 * @details
 */



#include <string>
#include <tuple>
#include <vector>
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @file
  * @brief OPS core library function declarations
  * @author Gihan Mudalige
  * @details function declarations header file for the core library functions
  * utilized by all OPS backends
  */
enum class REAL_PRECISION { Half = 16, Single = 32, Double = 64 };

/**
 * This routine defines a dataset to be read in from a named hdf5 file.
 *
 *
 * @param block      structured block
 * @param dat_size   dimension of dataset (number of items per grid element)
 * @param type       the name of type used for output diagnostics
 *                   (e.g. "double", "float")
 * @param dat_name   name of the dat used for output diagnostics
 * @param file_name  HDF5 file to read and obtain the data from
 * @return
 */

ops_dat ops_decl_dat_hdf5(ops_block block, int dat_size, char const *type,
                          char const *dat_name, char const *file_name);

/**
 * This routine reads the details of a structured grid block from a named
 * HDF5 file.
 *
 * Although this routine does not read in any extra information about the block
 * from the named HDF5 file than what is already specified in the arguments, it
 * is included here for error checking(e.g. check if blocks defined in an HDF5
 * file is matching with the declared arguments in an application) and
 * completeness.
 *
 * @param dims        dimension of the block
 * @param block_name  a name used for output diagnostics
 * @param file_name   HDF5 file to read and obtain the block information from
 * @return
 */

ops_block ops_decl_block_hdf5(int dims, const char *block_name,
                              char const *file_name);

/**
 *
 * @param dims          dimension of loop iteration
 * @param points        number of points in the stencil
 * @param stencil_name  string representing the name of the stencil
 * @param file_name     HDF5 file to read from
 * @return
 */

ops_stencil ops_decl_stencil_hdf5(int dims, int points,
                                  const char *stencil_name,
                                  char const *file_name);

/**
 *
 * @param dims          dimension of loop iteration
 * @param points        number of points in the stencil
 * @param stencil_name  string representing the name of the stencil
 * @param file_name     HDF5 file to read from
 * @return
 */

ops_stencil ops_decl_strided_stencil_hdf5(int dims, int points,
                                          const char *stencil_name,
                                          char const *file_name);

/**
 * This routine reads in a halo relationship between two datasets defined on
 * two different blocks from a named HDF5 file.
 *
 * @param from       origin dataset
 * @param to         destination dataset
 * @param file_name  HDF5 file to read and obtain the data from
 * @return
 */

ops_halo ops_decl_halo_hdf5(ops_dat from, ops_dat to, char const *file_name);

/**
 * Write the details of an ::ops_dat to a named HDF5 file.
 *
 * Can be used over MPI (puts the data in an ::ops_dat into an HDF5 file
 * using MPI I/O)
 * @param dat
 * @param file_name
 */

void ops_fetch_dat_hdf5_file(ops_dat dat, char const *file_name);

/**
 * Write the details of an ::ops_block to a named HDF5 file.
 *
 * Can be used over MPI (puts the data in an ::ops_block into an HDF5 file
 * using MPI I/O)
 *
 * @param block      ops block to be written
 * @param file_name  HDF5 file to write to
 */

void ops_fetch_block_hdf5_file(ops_block block, char const *file_name);

/**
 * Write the details of an ::ops_stencil to a named HDF5 file.
 *
 * Can be used over MPI (puts the data in an ::ops_stencil into an HDF5 file
 * using MPI I/O)
 *
 * @param stencil    ::ops_stencil to be written
 * @param file_name  HDF5 file to write to
 */

void ops_fetch_stencil_hdf5_file(ops_stencil stencil, char const *file_name);

/**
 * Write the details of an ::ops_halo to a named HDF5 file.
 *
 * Can be used over MPI (puts the data in an ::ops_halo into an HDF5 file
 * using MPI I/O)
 *
 * @param halo    ::ops_halo to be written
 * @param file_name  HDF5 file to write to
 */

void ops_fetch_halo_hdf5_file(ops_halo halo, char const *file_name);



void ops_read_dat_hdf5(ops_dat dat);


/**
 * Write all state (blocks, datasets, stencils) to a named HDF5 file.
 *
 * @param file_name  HDF5 file to write to
 */

void ops_dump_to_hdf5(char const *file_name);

void ops_write_const_hdf5(char const *name, int dim, char const *type,
                          char *const_data, char const *file_name);
void ops_get_const_hdf5(char const *name, int dim, char const *type,
                        char *const_data, char const *file_name);

/**
 * Write a hyperslab of ops_dat to HDF5 file. If the data_name follows the HDF5
 * convention (say block/time/data), data will be created under groups block and time.
* @param dat       the ops_dat holds the plane
 * @param range the range of ops_dat to be written
 * @param file_name  HDF5 file name ".h5"
 * @param data_name  data_name
 */
void ops_write_data_slab_hdf5(const ops_dat dat, const int *range,
                              const char *file_name, const char *data_name);

                              /**
 * Write a hyperslab of ops_dat to HDF5 file. If the data_name follows the HDF5
 * convention (say block/time/data), data will be created under groups block and time.
* @param dat       the ops_dat holds the plane
 * @param range the range of ops_dat to be written
 * @param file_name  HDF5 file name ".h5"
 * @param data_name  data_name
 * @param real_precision Half, Single, and Double, see enum class REAL_PRECISION
 */
void ops_write_data_slab_hdf5(const ops_dat dat, const int *range,
                              const char *file_name, const char *data_name,
                              REAL_PRECISION real_precision);

/**
 * Write data on a plane to HDF5 file. If the data_name follows the HDF5
 * convention (say block/time/data), data will be created under groups block and time. The array dimension will be reduced by one
* @param dat       the ops_dat holds the plane
 * @param cross_section_dir the plane direction (0:I, 1:J and 2:K)
 * @param pos the plane postion(e.g., 16 for I=16)
 * @param file_name  HDF5 file name ".h5"
 * @param data_name  data_name
 */
void ops_write_plane_hdf5(const ops_dat dat, const int cross_section_dir,
                          const int pos, char const *file_name,
                          const char *data_name);

/**
 * Write data on a plane to HDF5 file. If the data_name follows the HDF5
 * convention (say block/time/data), data will be created under groups block and time. The array dimension will be reduced by one
* @param dat       the ops_dat holds the plane
 * @param cross_section_dir the plane direction (0:I, 1:J and 2:K)
 * @param pos the plane postion(e.g., 16 for I=16)
 * @param file_name  HDF5 file name ".h5"
 * @param data_name  data_name
 * @param real_precision Half, Single, and Double, see enum class REAL_PRECISION
 */
void ops_write_plane_hdf5(const ops_dat dat, const int cross_section_dir,
                          const int pos, char const *file_name,
                          const char *data_name, REAL_PRECISION real_precision);

/**
 * Write a group of slices/planes of a group of ops_dats into a series of HDF5 files. Each HDF5 will named by I(J,K)Pos.h5, where all ops_dats for this
 plane will be wrote into this file. The slices will be named as blockname_datname_key

 * @param planes  plane groups specified as {{ cross_section_dir,pos},{...},{...},...}
 * @param key  a decoration to a dat name for distinguishing, e.g., time steps.
 * @param data       the ops_dat to be sliced
 * @param  ops_dats to be written, which specified as {{ops_dats at plane 0},{ops_dats at plane 1}...}
 */
void ops_write_plane_group_hdf5(
    const std::vector<std::pair<int, int>> &planes, const std::string &key,
    const std::vector<std::vector<ops_dat>> &data_list);

/**
 * Write a group of slices/planes of a group of ops_dats into a series of HDF5 files. Each HDF5 will be named as specified, where all ops_dats for this
 plane will be wrote into this file. The slices will be named as blockname_datname_key

 * @param planes  plane groups specified as {{ cross_section_dir,pos},{...},{...},...}
 * @param plane_names plane names
 * @param key  a decoration to a dat name for distinguishing, e.g., time steps.
 * @param data       the ops_dat to be sliced
 * @param  ops_dats to be written, which specified as {{ops_dats at plane 0},{ops_dats at plane 1}...}
 */
void ops_write_plane_group_hdf5(
    const std::vector<std::pair<int, int>> &planes,
    std::vector<std::string> &plane_names, const std::string &key,
    const std::vector<std::vector<ops_dat>> &data_list);

/**
 * Write a group of slices/planes of a group of ops_dats into a series of HDF5 files. Each HDF5 will named by I(J,K)Pos.h5, where all ops_dats for this
 plane will be wrote into this file. The slices will be named as blockname_datname_key

 * @param planes  plane groups specified as {{ cross_section_dir,pos},{...},{...},...}
 * @param key  a decoration to a dat name for distinguishing, e.g., time steps.
 * @param data       the ops_dat to be sliced
 * @param  ops_dats to be written, which specified as {{ops_dats at plane 0},{ops_dats at plane 1}...}
 * @param real_precision Half, Single, and Double, see enum class REAL_PRECISION
 */
void ops_write_plane_group_hdf5(
    const std::vector<std::pair<int, int>> &planes, const std::string &key,
    const std::vector<std::vector<ops_dat>> &data_list,
    REAL_PRECISION real_precision);

/**
 * Write a group of slices/planes of a group of ops_dats into a series of HDF5 files. Each HDF5 will be named as specified, where all ops_dats for this
 plane will be wrote into this file. The slices will be named as blockname_datname_key

 * @param planes  plane groups specified as {{ cross_section_dir,pos},{...},{...},...}
 * @param plane_names plane names
 * @param key  a decoration to a dat name for distinguishing, e.g., time steps.
 * @param data       the ops_dat to be sliced
 * @param  ops_dats to be written, which specified as {{ops_dats at plane 0},{ops_dats at plane 1}...}
 * @param real_precision Half, Single, and Double, see enum class REAL_PRECISION
 */
void ops_write_plane_group_hdf5(
    const std::vector<std::pair<int, int>> &planes,
    std::vector<std::string> &plane_names, const std::string &key,
    const std::vector<std::vector<ops_dat>> &data_list,
    REAL_PRECISION real_precision);


/* __OPS_HDF5_H */
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* * The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @file
  * @brief OPS tridiagonal API header file
  * @author Gihan Mudalige
  * @details This header file should be included by all C++
  * OPS applications using the OPS Tridiagonal API
  */
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @file
  * @brief OPS core library function declarations
  * @author Gihan Mudalige
  * @details function declarations header file for the core library functions
  * utilized by all OPS backends
  */
class ops_tridsolver_params {
public:
  enum SolveStrategy {
    GATHER_SCATTER = 0, // Gather boundaries on first nodes solve reduced system
                        // and scatter results
    ALLGATHER,          // Gather boundaries and solve reduced on all nodes
    JACOBI,             // Use Jacobi iterations to solve the reduced system
    PCR,                // Use PCR to solve the reduced system
    LATENCY_HIDING_INTERLEAVED, // Perform solves in mini-batches. Do forward
                                // run of the current mini-batch start
                                // communication and finish the previous
                                // mini-batch
    LATENCY_HIDING_TWO_STEP     // Perform solves in min-batches. First step:
                            // forwards and start communication, second step:
                            // wait for ready requests and finish mini-batches
  };

  ops_tridsolver_params(ops_block block);
  ops_tridsolver_params(ops_block block, SolveStrategy strategy);
  ~ops_tridsolver_params();

  void set_jacobi_params(double rtol, double atol, int maxiter);
  void set_batch_size(int batch_size);
  void set_cuda_opts(int opt_x, int opt_y, int opt_z);
  void set_cuda_sync(int sync);

  void *tridsolver_params;
};


void ops_tridMultiDimBatch(int ndim, int solvedim, int* range, ops_dat a,
                           ops_dat b, ops_dat c, ops_dat d,
                           ops_tridsolver_params *tridsolver_ctx);


void ops_tridMultiDimBatch_Inc(int ndim, int solvedim, int* range, ops_dat a,
                               ops_dat b, ops_dat c, ops_dat d, ops_dat u,
                               ops_tridsolver_params *tridsolver_ctx);
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @brief ops core library function declarations
  * @author Gihan Mudalige
  * @details function declarations header file for the core library functions
  * utilized by all OPS backends
  */




#include <vector>





class OPS_instance_tiling;
class OPS_instance_checkpointing;
class OPS_instance_opencl;
class OPS_instance_sycl;

/**
 * This class encapsulates "global" scope data required for OPS instances.
 * To support multiple instances of OPS in a shared memory environment,
 * you need to add support for your own threading library in the implementation
 * of getOPSInstance() in src/core/ops_instance.cpp
 *
 * Currently supported threading libraries: OpenMP
 */

class OPS_instance {
  public:
    std::ostream& ostream() {return *_ostream;}
    void set_ostream(std::ostream &s);

  	static OPS_instance* getOPSInstance();


   static int numInstances();

  	OPS_instance();

// #ifdef OPS_CPP_API
 /**
 * This routine must be called before all other OPS routines.
 *
 * @param argc         the usual command line argument
 * @param argv         the usual command line argument
 * @param diags_level  an integer which defines the level of debugging
 *                     diagnostics and reporting to be performed.
 *                     Can be overridden with the -OPS_DIAGS= runtime argument
 *
 * Currently, higher `diags_level`s perform the following checks:
 *
 * | diags level | checks                                                      |
 * | ----------- | ----------------------------------------------------------- |
 * |  = 1        | no diagnostics, default to achieve best runtime performance.|
 * |  > 1        | print block decomposition and ops par loop timing breakdown.|
 * |  > 4        | print intra-block halo buffer allocation feedback (for OPS internal development only)                 |
 * |  > 5        | check if intra-block halo MPI sends depth match MPI receives depth (for OPS internal development only)|
 *
 */
  	OPS_instance(const int argc, const char *const argv[], const int diags_level, std::ostream &ostream = std::cout);

    void exit();
    ~OPS_instance() {
      this->exit();
    }

/**
 * This routine defines a structured grid block.
 *
 * @param dims  dimension of the block
 * @param name  a name used for output diagnostics
 * @return
 */
    ops_block decl_block(int dims, const char * name);
/**
 * This routine defines a reduction handle to be used in a parallel loop.
 *
 * @param size  size of data in bytes
 * @param type  the name of type used for output diagnostics
 *              (e.g. "double", "float")
 * @param name  name of the dat used for output diagnostics
 * @return
 */
    ops_reduction decl_reduction_handle(int size, const char *type,
                                         const char *name);
/**
 * This routine defines a stencil.
 *
 * @param dims     dimension of loop iteration
 * @param points   number of points in the stencil
 * @param stencil  stencil for accessing data
 * @param name     string representing the name of the stencil
 * @return
 */
    ops_stencil decl_stencil(int dims, int points, int *stencil,
                              char const *name);
/**
 * This routine defines a strided stencil.
 *
 * The semantics for the index of data to be accessed, for stencil point `p`,
 * in dimension `m` are defined as:
 * ```
 *    stride[m]*loop index[m] + stencil[p*dims+m]
 * ```
 * where `loop_index[m]` is the iteration index (within the user-defined
 * iteration space) in the different dimensions.
 * If, for one or more dimensions, both `stride[m]` and `stencil[p*dims+m]`
 * are zero, then one of the following must be true;
 *   - the dataset being referenced has size 1 for these dimensions
 *   - these dimensions are to be omitted and so the dataset has dimension
 *     equal to the number of remaining dimensions.
 *
 * @param dims     dimension of loop iteration
 * @param points   number of points in the stencil
 * @param stencil  stencil for accessing data
 * @param stride   stride for accessing data
 * @param name     string representing the name of the stencil
 * @return
 */
    ops_stencil decl_strided_stencil(int dims, int points, int *sten,
                                     int *stride, char const *name);
    ops_stencil decl_restrict_stencil( int dims, int points, int *sten,
                                       int *stride, char const * name);
    ops_stencil decl_prolong_stencil( int dims, int points, int *sten,
                                      int *stride, char const * name);
/**
 * This routine defines a halo relationship between two datasets defined on two
 * different blocks.
 *
 * A @p from_dir [1,2] and a @p to_dir [2,1] means that x in the first block
 * goes to y in the second block, and y in first block goes to x in second
 * block.
 * A negative sign indicates that the axis is flipped.
 *
 * (Simple example: a transfer from (1:2,0:99,0:99) to (-1:0,0:99,0:99) would
 * use @p iter_size = [2,100,100], @p from_base = [1,0,0],
 * @p to_base = [-1,0,0], @p from_dir = [0,1,2], @p to_dir = [0,1,2].
 * In more complex cases this allows for transfers between blocks with
 * different orientations.)
 *
 * @param from       origin dataset
 * @param to         destination dataset
 * @param iter_size  defines an iteration size
 *                   (number of indices to iterate over in each direction)
 * @param from_base  indices of starting point in @p from dataset
 * @param to_base    indices of starting point in @p to dataset
 * @param from_dir   direction of incrementing for @p from for each dimension
 *                   of @p iter_size
 * @param to_dir     direction of incrementing for @p to for each dimension
 *                   of @p iter_size
 * @return
 */
    ops_halo decl_halo(ops_dat from, ops_dat to, int *iter_size, int *from_base,
                       int *to_base, int *from_dir, int *to_dir);
/**
 * This routine defines a collection of halos.
 * Semantically, when an exchange is triggered for all halos
 * in a group, there is no order defined in which they are carried out.
 *
 * @param nhalos  number of halos in @p halos
 * @param halos   array of halos
 * @return
 */
    ops_halo_group decl_halo_group(int nhalos, ops_halo *halos);

/**
 * This routine defines a global constant: a variable in global scope.
 *
 * Global constants need to be declared upfront so that they can be correctly
 * handled for different parallelizations. For e.g. CUDA on GPUs.
 * Once defined they remain unchanged throughout the program, unless changed
 * by a call to ops_update_const().
 * @tparam T
 * @param name  a name used to identify the constant
 * @param dim   dimension of dataset (number of items per element)
 * @param type  the name of type used for output diagnostics
 *              (e.g. "double", "float")
 * @param data  pointer to input data of type @p T
 */
    template <class T>
    void decl_const(char const *name, int dim, char const *type, T *data) {
      if (type_error(data, type)) {
        OPSException ex(5);
        ex << "Error: incorrect type specified for constant " << name
           << " in OPS_instance::decl_const";
        throw ex;
      }
      ops_decl_const_char(this, dim, type, sizeof(T), (char *)data, name);
    }

/**
 * This routine updates/changes the value of a constant.
 *
 * @tparam T
 * @param name  a name used to identify the constant
 * @param dim   dimension of dataset (number of items per element)
 * @param type  the name of type used for output diagnostics
 *              (e.g. "double", "float")
 * @param data  pointer to input data of type @p T
 */
    template <class T>
    void update_const(char const *name, int dim, char const *type, T *data) {
      decl_const(name, dim, type, data);
    }

/**
 * This routine prints out various useful bits of diagnostic info about sets,
 * mappings and datasets.
 *
 * Usually used right after an @p ops partition() call to print out the details
 * of the decomposition.
 */
    void diagnostic_output();
/**
 * Print OPS performance performance details to output stream.
 *
 * @param stream  output stream, use std::cout to print to standard out
 */
    void timing_output(std::ostream &stream);
    void timing_output_stdout();

/**
 * Returns one one the root MPI process
 */
    int is_root();

/**
 * Triggers a multi-block partitioning across a distributed memory set of
 * processes.
 * (links to a dummy function for single node parallelizations).
 * This routine should only be called after all the ops_decl_block() and
 * ops_decl_dat() statements have been declared. Must be called before any
 * calling any parallel loops
 *
 * @param routine  string describing the partitioning method.
 *                 Currently this string is not used internally, but is simply
 *                 a place-holder to indicate different partitioning methods
 *                 in the future.
 */
    void partition(const char *routine);
	void partition(const char *routine, std::map<std::string, void*>& opts);
// #endif

	/*******************************************************************************
	* Global constants
	*******************************************************************************/


	//Blocks, Dats, Stencils Halos, Reductions
	int OPS_block_index, OPS_block_max, OPS_dat_index, OPS_dat_max,
	OPS_halo_group_index, OPS_halo_group_max, OPS_halo_index, OPS_halo_max,
	OPS_reduction_index, OPS_reduction_max, OPS_stencil_index, OPS_stencil_max;
	ops_block_descriptor *OPS_block_list;
	ops_stencil *OPS_stencil_list;
	ops_halo *OPS_halo_list;
	ops_halo_group *OPS_halo_group_list;
	Double_linked_list OPS_dat_list;
	ops_reduction *OPS_reduction_list;


	// Checkpointing
 	int OPS_enable_checkpointing;
	double OPS_checkpointing_time;
	int ops_thread_offload;
	int ops_checkpoint_inmemory;
	int ops_lock_file;
	ops_backup_state backup_state;
	char *OPS_dat_ever_written;
	ops_checkpoint_types *OPS_dat_status;
	int OPS_ranks_per_node;

	//SEQ execution
	int arg_idx[5];


	// Debugging
	ops_arg *OPS_curr_args;
	const char *OPS_curr_name;

	//Diagnostics
	int OPS_kern_max, OPS_kern_curr;
	ops_kernel *OPS_kernels;
	double ops_user_halo_exchanges_time;

	//Tiling
	int ops_enable_tiling;
	int ops_cache_size;
	int ops_tiling_mpidepth;
	double ops_tiled_halo_exchange_time;
	OPS_instance_tiling *tiling_instance;
	OPS_instance_checkpointing *checkpointing_instance;
  	int tilesize_x, tilesize_y, tilesize_z;

	//Other runtime configuration args
	std::vector<int> ops_force_decomp_x;
	std::vector<int> ops_force_decomp_y;
	std::vector<int> ops_force_decomp_z;
	std::vector<int> processes_per_block;
	int OPS_realloc;
	int OPS_soa;
	int OPS_diags;

	// CUDA & OpenCL
	int OPS_hybrid_gpu, OPS_gpu_direct;
	int OPS_block_size_x;
	int OPS_block_size_y;
	int OPS_block_size_z;
	char *OPS_consts_h, *OPS_consts_d, *OPS_reduct_h, *OPS_reduct_d;
	int OPS_consts_bytes, OPS_reduct_bytes;
	int OPS_cl_device;
	char *ops_halo_buffer;
	char *ops_halo_buffer_d;
	int ops_halo_buffer_size;
	int OPS_gbl_changed;
	char *OPS_gbl_prev;
	OPS_instance_opencl *opencl_instance;
	OPS_instance_sycl *sycl_instance;

	int is_initialised;

	ops_stencil OPS_internal_0[5];
private:
	void init_globals();
  	std::ostream *_ostream;
};
template <typename T>
void ops_decl_const2(char const *name, int dim, char const *type, T *data) {
  ops_decl_const_char(OPS_instance::getOPSInstance(), dim, type, sizeof(T),
                      (char *)data, name);
}
inline int mult(int* size, int dim)
{
  int result = 1;
  if(dim > 0) {
    for(int i = 0; i<dim;i++) result *= size[i];
  }
  return result;
}

inline int add(int* coords, int* size, int dim)
{
  int result = coords[0];
  for(int i = 1; i<=dim;i++) result += coords[i]*mult(size,i);
  return result;
}


inline int off(int ndim, int dim , int* start, int* end, int* size, int* stride)
{

  int i = 0;
  int c1[5];
  int c2[5];

  for(i=0; i<=dim; i++) c1[i] = start[i]+1;
  for(i=dim+1; i<ndim; i++) c1[i] = start[i];

  for(i = 0; i<dim; i++) c2[i] = end[i];
  for(i=dim; i<ndim; i++) c2[i] = start[i];

  for (i = 0; i < ndim; i++) {
    c1[i] *= stride[i];
    c2[i] *= stride[i];
  }
  int off =  add(c1, size, dim) - add(c2, size, dim);

  return off;
}

inline int address(int ndim, int dat_size, int* start, int* size, int* stride, int* base_off, int *d_m)
{
  int base = 0;
  for(int i=0; i<ndim; i++) {
    base = base + dat_size * mult(size, i) * (start[i] * stride[i] - base_off[i] - d_m[i]);
  }
  return base;
}

inline void stencil_depth(ops_stencil sten, int* d_pos, int* d_neg)
{
  for(int dim = 0;dim<sten->dims;dim++){
    d_pos[dim] = 0; d_neg[dim] = 0;
  }
  for(int p=0;p<sten->points; p++) {
    for(int dim = 0;dim<sten->dims;dim++){
    d_pos[dim] = ((d_pos[dim] > sten->stencil[sten->dims*p + dim]) ? (d_pos[dim]) : (sten->stencil[sten->dims*p + dim]));
    d_neg[dim] = ((d_neg[dim] < sten->stencil[sten->dims*p + dim]) ? (d_neg[dim]) : (sten->stencil[sten->dims*p + dim]));
    }
  }
}









































































































































































































































/**
 * Performs a parallel loop, executing the user-defined function kernel,
 * passing data as specified by the list arguments. The iteration space
 * is dim dimensional, and the bounds are specified by range
 *
 * Arguments to kernel are passed through as ACC<datatype>& references
 * for ops_dats, and need to be accessed with the overloaded () operator.
 * For other types of arguments, pointers are passed that can be
 * dereferenced directly
 *
 * @param kernel   user kernel, #of arguments must match the ops_arg parameters
 * @param name     a name for the parallel loop
 * @param block    the ops_block to iterate on
 * @param dim      dimensionality of the block
 * @param range    loop bounds in the following order: {dim0_lower,
 *                 dim0_upper_exclusive, dim1_lower, ...}
 * @param arguments a list of ops_arg arguments
 */
template <typename... ParamType, typename... OPSARG>
void ops_par_loop(void (*kernel)(ParamType...), char const *name,
                  ops_block block, int dim, int *range,
                  OPSARG... arguments) {
  static_assert(sizeof...(ParamType) == sizeof...(OPSARG),
      "number of parameters of the kernel shoud match the number of ops_arg");
  ops_par_loop_impl(build_indices<sizeof...(ParamType)>{}, kernel, name,
                    block, dim, range, arguments...);
}
void kernel_populate(ACC<float> &u) {

  u(0,0,0) = myfun();
}

void kernel_initialguess(ACC<float> &u) {
  u(0,0,0) = 0.0;
}

void jac3D_kernel_stencil(const ACC<float> &u,
                            ACC<float> &u2) {

    float tmp1 = u(0,0,1) * (0.02f);
    float tmp2 = u(0,1,0) * (0.04f);
    float tmp3 = u(-1,0,0) * (0.05f);
    float tmp4 = u(0,0,0) * (0.79f);
    float tmp5 = u(1,0,0) * (0.06f);
    float tmp6 = u(0,-1,0) * (0.03f);
    float tmp7 = u(0,0,-1) * (0.01f);
    float tmp8 = tmp1 + tmp2;
    float tmp9 = tmp3 + tmp4;
    float tmp10 = tmp5 + tmp6;
    float tmp11 = tmp7 + tmp8;
    float tmp12 = tmp9 + tmp10;
    u2(0,0,0) = tmp11 + tmp12;
}

void kernel_copy(const ACC<float> &u2, ACC<float> &u) {
  u(0,0,0) = u2(0,0,0);
}
/*
* Open source copyright declaration based on BSD open source template:
* http://www.opensource.org/licenses/bsd-license.php
*
* This file is part of the OPS distribution.
*
* Copyright (c) 2013, Mike Giles and others. Please see the AUTHORS file in
* the main source directory for a full list of copyright holders.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
* * The name of Mike Giles may not be used to endorse or promote products
* derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** @Test application for fpga batched temporal blocked jacobian 2D
  * @author Beniel Thileepan, Kamalavasan Kamalakannan
  */



#include <math.h>


typedef float stencil_type;
extern const unsigned short mem_vector_factor;

void initialise_grid(stencil_type* u, int size[3], int d_m[3], int d_p[3], int range[6])
{
    int grid_size_z = size[2] - d_m[2] + d_p[2];
    int grid_size_y = size[1] - d_m[1] + d_p[1];

    int grid_size_x = ((size[0] - d_m[0] + d_p[0] + mem_vector_factor - 1) / mem_vector_factor) * mem_vector_factor;



    int actual_size_x = size[0] - d_m[0] + d_p[0];


    for (int k = range[4] - d_m[2]; k < range[5] - d_m[2]; k++)
    {
        for (int j = range[2] - d_m[1]; j < range[3] -d_m[1]; j++)
        {
            for (int i = range[0] - d_m[0]; i < range[1] - d_m[0]; i++)
            {
                int index = k * grid_size_y * grid_size_x + j * grid_size_x + i;
                if(i == 0 || j == 0 || k == 0 || i == actual_size_x -1  || j==grid_size_y-1 || k==grid_size_y-1)
                {
                    float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
                    u[index] = r;
                }
                else
                {
                    u[index] = 0;
                }
            }
        }
    }
}

void stencil_computation(stencil_type* u, stencil_type* u2, int size[3], int d_m[3], int d_p[3], int range[6])
{
    int grid_size_z = size[2] - d_m[2] + d_p[2];
    int grid_size_y = size[1] - d_m[1] + d_p[1];

    int grid_size_x = ((size[0] - d_m[0] + d_p[0] + mem_vector_factor - 1) / mem_vector_factor) * mem_vector_factor;



    int actual_size_x = size[0] - d_m[0] + d_p[0];


    for (int k = range[4] - d_m[2]; k < range[5] - d_m[2]; k++)
    {
        for (int j = range[2] - d_m[1]; j < range[3] -d_m[1]; j++)
        {
            for (int i = range[0] - d_m[0]; i < range[1] - d_m[0]; i++)
            {
                int index = k * grid_size_y * grid_size_x + j * grid_size_x + i;
                if(i == 0 || j == 0 || k == 0 || i == actual_size_x -1  || j==grid_size_y-1 || k==grid_size_y-1)
                {
			    u2[index] = u[index];
                }
                else
                {
                    u2[index] = u[(k+1)* grid_size_x * grid_size_y + (j)*grid_size_x + (i)] * (0.02f) + u[(k)* grid_size_x * grid_size_y + (j+1)*grid_size_x + (i)] * (0.04f) + u[(k)* grid_size_x * grid_size_y + (j)*grid_size_x + (i-1)] * (0.05f) + u[(k)* grid_size_x * grid_size_y + (j)*grid_size_x + (i)] * (0.79f) + u[(k)* grid_size_x * grid_size_y + (j)*grid_size_x + (i+1)] * (0.06f) + u[(k)* grid_size_x * grid_size_y + (j-1)*grid_size_x + (i)] * (0.03f) + u[(k-1)* grid_size_x * grid_size_y + (j)*grid_size_x + (i)] * (0.01f);






                }
            }
        }
    }
}

void copy_grid(stencil_type* u2, stencil_type* u, int size[3], int d_m[3], int d_p[3], int range[6])
{
    int grid_size_z = size[2] - d_m[2] + d_p[2];
    int grid_size_y = size[1] - d_m[1] + d_p[1];

    int grid_size_x = ((size[0] - d_m[0] + d_p[0] + mem_vector_factor - 1) / mem_vector_factor) * mem_vector_factor;



    int actual_size_x = size[0] - d_m[0] + d_p[0];


    for (int k = range[4] - d_m[2]; k < range[5] - d_m[2]; k++)
    {
        for (int j = range[2] - d_m[1]; j < range[3] -d_m[1]; j++)
        {
            for (int i = range[0] - d_m[0]; i < range[1] - d_m[0]; i++)
            {
                int index = k * grid_size_y * grid_size_x + j * grid_size_x + i;
                u2[index] = u[index];
            }
        }
    }
}


bool verify(stencil_type * grid_data1, stencil_type *  grid_data2, int size[2], int d_m[2], int d_p[2], int range[4])
{
    bool passed = true;
    int grid_size_z = size[2] - d_m[2] + d_p[2];
    int grid_size_y = size[1] - d_m[1] + d_p[1];

    int grid_size_x = ((size[0] - d_m[0] + d_p[0] + mem_vector_factor - 1) / mem_vector_factor) * mem_vector_factor;



    int actual_size_x = size[0] - d_m[0] + d_p[0];


    for (int k = range[4] - d_m[2]; k < range[5] - d_m[2]; k++)
    {
        for (int j = range[2] - d_m[1]; j < range[3] -d_m[1]; j++)
        {
            for (int i = range[0] - d_m[0]; i < range[1] - d_m[0]; i++)
            {
                int index = k * grid_size_y * grid_size_x + j * grid_size_x + i;
                if(i == 0 || j == 0 || k == 0 || i == actual_size_x -1  || j==grid_size_y-1 || k==grid_size_y-1)
                {
                    if (fabs(grid_data1[index] - grid_data2[index])/(fabs(grid_data1[index]) + fabs(grid_data2[index])) > 0.0001)
                    {
                        std::cerr << "[ERROR] value Mismatch index: (" << i << ", " << j << ", " << k << "), grid_data1: "
                                << grid_data1[index] << ", and grid_data2: " << grid_data2[index] << std::endl;
                        passed = false;
                    }
                }
            }
        }
    }

    return passed;
}
/******************************************************************************
* Main program
*******************************************************************************/
int main(int argc, const char **argv)
{
  /**-------------------------- Initialisation --------------------------**/

    // OPS initialisation
    ops_init(argc,argv,1);


    //Mesh
    int imax = 20;
    int jmax = 20;
    int kmax = 20;
    unsigned int iter_max = 135;
    unsigned int batches = 1;

    const char* pch;
    for ( int n = 1; n < argc; n++ )
    {
        pch = strstr(argv[n], "-sizex=");

        if(pch != NULL) {
            imax = atoi ( argv[n] + 7 ); continue;
        }
        pch = strstr(argv[n], "-sizey=");

        if(pch != NULL) {
            jmax = atoi ( argv[n] + 7 ); continue;
        }
        pch = strstr(argv[n], "-sizez=");

        if(pch != NULL) {
            kmax = atoi ( argv[n] + 7 ); continue;
        }
        pch = strstr(argv[n], "-iters=");

        if(pch != NULL) {
            iter_max = atoi ( argv[n] + 7 ); continue;
        }
        pch = strstr(argv[n], "-batch=");

        if(pch != NULL) {
            batches = atoi ( argv[n] + 7 ); continue;
        }







    }
















    //The 2D block
    ops_block blocks[batches];

    for (unsigned int bat = 0; bat < batches; bat++)
    {
        std::string name = std::string("batch_") + std::to_string(bat);
        blocks[bat] = ops_decl_block(3, name.c_str());
    }


    //declare stencils
    int s3D_00[] = {0,0,0};
    ops_stencil S3D_00 = ops_decl_stencil(3, 1, s3D_00, "00");
    int s3D_7pt[] = {0,0,-1, 0,-1,0, -1,0,0, 0,0,0, 1,0,0, 0,1,0, 0,0,1};
    ops_stencil S3D_7PT = ops_decl_stencil(3, 7, s3D_7pt, "s3D_7pt_stencil");

    //declare datasets
    int size[] = {imax, jmax, kmax};
    int base[] = {0,0,0};
    int d_m[] = {-1,-1,-1};
    int d_p[] = {1,1,1};
    float* temp = NULL;

    ops_dat u[batches];
    ops_dat u2[batches];
    ops_dat f[batches];
    ops_dat ref[batches];















    // Allocation
    for (unsigned int bat = 0; bat < batches; bat++)
    {
        std::string name = std::string("u_") + std::to_string(bat);
        u[bat] = ops_decl_dat(blocks[bat], 1, size, base, d_m, d_p, temp, "float", name.c_str());
        name = std::string("u2_") + std::to_string(bat);
        u2[bat] = ops_decl_dat(blocks[bat], 1, size, base, d_m, d_p, temp, "float", name.c_str());
        name = std::string("f_") + std::to_string(bat);
        f[bat] = ops_decl_dat(blocks[bat], 1, size, base, d_m, d_p, temp, "float", name.c_str());
        name = std::string("ref_") + std::to_string(bat);
        ref[bat] = ops_decl_dat(blocks[bat], 1, size, base, d_m, d_p, temp, "float", name.c_str());






    }

    ops_partition("");

    int full_range[] = {d_m[0], size[0] + d_p[0], d_m[1], size[1] + d_p[1],  d_m[2], size[2] + d_p[2]};
    int internal_range[] = {0, size[0], 0, size[1], 0, size[2]};
    //Producer
    for (unsigned int bat = 0; bat < batches; bat++)
    {














        ops_par_loop(kernel_populate, "kernel_populate", blocks[bat], 3, full_range,
                ops_arg_dat(u[bat], 1, S3D_00, "float", 1));

        ops_par_loop(kernel_initialguess, "kernel_initialguess", blocks[bat], 3, internal_range,
                ops_arg_dat(u[bat], 1, S3D_00, "float", 1));

        ops_par_loop(kernel_copy, "kernel_update", blocks[bat], 3, full_range,
                ops_arg_dat(u[bat], 1, S3D_00, "float", 0),
                ops_arg_dat(u2[bat], 1, S3D_00, "float", 1));






















    }





    //iterative stencil loop
    for (unsigned int bat = 0; bat < batches; bat++)
    {
        ops_printf("Launching jacobian3d calculation: %d x %d x %d mesh\n", size[0], size[1], size[2]);






        for (int iter = 0; iter < iter_max; iter++)
        {
            ops_par_loop(jac3D_kernel_stencil, "jac2D_kernel_stencil", blocks[bat], 3, internal_range,
                    ops_arg_dat(u[bat], 1, S3D_7PT, "float", 0),
                    ops_arg_dat(u2[bat], 1, S3D_00, "float", 1));

            ops_par_loop(kernel_copy, "kernel_update", blocks[bat], 3, internal_range,
                    ops_arg_dat(u2[bat], 1, S3D_00, "float", 0),
                    ops_arg_dat(u[bat], 1, S3D_00, "float", 1));
        }









    }



    //Final Verification after calc




























    //cleaning
    for (unsigned int bat = 0; bat < batches; bat++)
    {
        ops_free_dat(u[bat]);
        ops_free_dat(u2[bat]);
        ops_free_dat(f[bat]);
        ops_free_dat(ref[bat]);






    }




















































































    ops_exit();

    std::cout << "Exit properly" << std::endl;
    return 0;
}
==================================================================================================================================================================