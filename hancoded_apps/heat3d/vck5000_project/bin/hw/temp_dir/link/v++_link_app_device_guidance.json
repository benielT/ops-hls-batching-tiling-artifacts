{
 "session": {
  "name": "v++_link_app_device",
  "uuid": "97a06472-0f17-4cf8-bfd6-066e6b09d7cd",
  "description": "v++ --xp vivado_param:project.ensureVersalHasCIPS=false --xp vivado_param:bd.enableAutoConnectionsInNoc=1 --xp vivado_param:constr.restoreXDEFConstraintsASTCL=1 --xp vivado_param:ips.enableSLRParameter=4  -s -O3 --target hw --platform xilinx_vck5000_gen4x8_xdma_2_202210_1 --hls.jobs 32 --remote_ip_cache /home/x_thileeb/repos/ops-hls-pact25-artifact/hancoded_apps/heat3d/vck5000_project/../../IP_CACHE --temp_dir bin/hw/temp_dir/link/ --log_dir bin/hw/temp_dir/link/logs/ --link --config stencil_single_SLR_vck5000.cfg -o ./bin/hw/app_device.xsa ./bin/hw/mem2stream.xo ./bin/hw/SLR.xo ",
  "timestamp": "0",
  "report_file": {
   "scheme": "FILE",
   "host": "",
   "port": 0,
   "path": "/home/x_thileeb/repos/ops-hls-pact25-artifact/hancoded_apps/heat3d/vck5000_project/bin/hw/temp_dir/link/reports/link/v++_link_app_device_guidance.html",
   "query": "",
   "fragment": "",
   "media_type": "",
   "encoding": "",
   "data": ""
  },
  "proto_file": {
   "scheme": "FILE",
   "host": "",
   "port": 0,
   "path": "/home/x_thileeb/repos/ops-hls-pact25-artifact/hancoded_apps/heat3d/vck5000_project/bin/hw/temp_dir/link/v++_link_app_device_guidance.pb",
   "query": "",
   "fragment": "",
   "media_type": "",
   "encoding": "",
   "data": ""
  },
  "build_target": "",
  "config_files": [
   {
    "fileName": "stencil_single_SLR_vck5000.cfg",
    "contents": "[connectivity]\nstream_connect=stencil_mem2stream_1.out:stencil_SLR_1.in:1024\nstream_connect=stencil_SLR_1.out:stencil_mem2stream_1.in:1024\n\nslr=stencil_mem2stream_1:SLR0\nslr=stencil_SLR_1:SLR0\n"
   }
  ]
 },
 "violation_count": 2,
 "waived_count": 0,
 "affirmation_count": 2,
 "violations": {
  "hashmap": {
   "2": {
    "id": 2,
    "severity": "SEV_CRITICAL_WARNING",
    "rule_key": "ACCELERATOR-FIT-02",
    "examples": {
     "uri": [
      {
       "link_text": "This page",
       "url": {
        "scheme": "HTTPS",
        "host": "www.xilinx.com",
        "port": 0,
        "path": "/cgi-bin/docs/rdoc?t=vitis+guidance;v=2022.1;d=ACCELERATOR-FIT-02.html",
        "query": "",
        "fragment": "",
        "media_type": "",
        "encoding": "",
        "data": ""
       },
       "docgen_filename": ""
      }
     ]
    },
    "build_target": "",
    "expects": "",
    "details": {
     "text": "The design requires more BlockRAM resources than are available. The total number of BlockRAM elements required by all kernels is 969.000000, out of 967.000000 available (utilization threshold 0.800000). ",
     "args": {
      "arg": [
       {
        "scalar": {
         "int_val": "0",
         "double_val": 969,
         "string_val": "",
         "address": "",
         "units": ""
        },
        "string_val": ""
       },
       {
        "scalar": {
         "int_val": "0",
         "double_val": 967,
         "string_val": "",
         "address": "",
         "units": ""
        },
        "string_val": ""
       },
       {
        "scalar": {
         "int_val": "0",
         "double_val": 0.8,
         "string_val": "",
         "address": "",
         "units": ""
        },
        "string_val": ""
       }
      ]
     }
    },
    "resolution": {
     "text": "A BlockRAM is an internal memory resource that can be configured in a variety of sizes. Almost every design built within an FPGA requires the use of internal memory resources of some size for storage of coefficients, buffering of data, and a variety of other uses. !URI%1! describes ways to reduce the number of required BlockRAM resources.",
     "args": {
      "arg": [
       {
        "uri": {
         "link_text": "This page",
         "url": {
          "scheme": "HTTPS",
          "host": "www.xilinx.com",
          "port": 0,
          "path": "/cgi-bin/docs/rdoc?t=vitis+guidance;v=2022.1;d=ACCELERATOR-FIT-02.html",
          "query": "",
          "fragment": "",
          "media_type": "",
          "encoding": "",
          "data": ""
         },
         "docgen_filename": ""
        },
        "string_val": ""
       }
      ]
     }
    },
    "categories": {
     "2": "Resource",
     "3": "Local Memory",
     "0": "Accelerator",
     "1": "Kernel"
    },
    "extended_categories": {},
    "impact": "IMPACT_UNKNOWN",
    "group": ""
   },
   "3": {
    "id": 3,
    "severity": "SEV_ADVISORY",
    "rule_key": "AUTO-FREQ-SCALING-08",
    "examples": {
     "uri": [
      {
       "link_text": "setting",
       "url": {
        "scheme": "HTTPS",
        "host": "www.xilinx.com",
        "port": 0,
        "path": "/cgi-bin/docs/rdoc?t=vitis+guidance;v=2022.1;d=AUTO-FREQ-SCALING-08.html",
        "query": "",
        "fragment": "",
        "media_type": "",
        "encoding": "",
        "data": ""
       },
       "docgen_filename": ""
      }
     ]
    },
    "build_target": "",
    "expects": "",
    "details": {
     "text": "For clock !%0!, the auto scaled frequency 554.6 MHz exceeds the original specified frequency. The compiler will select the original specified frequency of 500.0 MHz.",
     "args": {
      "arg": [
       {
        "ref": {
         "type": "REPORT",
         "name": "clk_kernel_01_unbuffered_net",
         "id": 0,
         "uuid": "",
         "url": {
          "scheme": "FILE",
          "host": "",
          "port": 0,
          "path": "/home/x_thileeb/repos/ops-hls-pact25-artifact/hancoded_apps/heat3d/vck5000_project/bin/hw/temp_dir/link/link/vivado/vpl/prj/prj.runs/impl_1/dr_timing_summary.rpt",
          "query": "",
          "fragment": "",
          "media_type": "",
          "encoding": "",
          "data": ""
         },
         "report_type": "GLOBAL_REPORT_TIMING_SUMMARY_FAIL"
        },
        "string_val": ""
       },
       {
        "string_val": "554.6"
       },
       {
        "string_val": "500.0"
       }
      ]
     }
    },
    "resolution": {
     "text": "The automatic frequency scaling feature allows user kernels to operate in hardware, even if at a lower frequency than intended. In this case the clock may in fact be able to run at a higher frequency than specified. You may want to consider !URI%1! the clock frequency higher for better performance. The '--kernel_frequency' option is one way to control the frequency specification.",
     "args": {
      "arg": [
       {
        "uri": {
         "link_text": "setting",
         "url": {
          "scheme": "HTTPS",
          "host": "www.xilinx.com",
          "port": 0,
          "path": "/cgi-bin/docs/rdoc?t=vitis+guidance;v=2022.1;d=AUTO-FREQ-SCALING-08.html",
          "query": "",
          "fragment": "",
          "media_type": "",
          "encoding": "",
          "data": ""
         },
         "docgen_filename": ""
        },
        "string_val": ""
       }
      ]
     }
    },
    "categories": {
     "1": "app_device",
     "2": "Performance",
     "0": "Accelerator"
    },
    "extended_categories": {},
    "impact": "IMPACT_UNKNOWN",
    "group": ""
   }
  }
 },
 "affirmations": {
  "hashmap": {
   "1": {
    "id": 1,
    "rule_key": "SYSLINK-1",
    "examples": {
     "uri": []
    },
    "build_target": "",
    "expects": "",
    "details": {
     "text": "Created top level block diagram design dr.bd.tcl",
     "args": {
      "arg": [
       {
        "string_val": "dr.bd.tcl"
       }
      ]
     }
    },
    "categories": {},
    "extended_categories": {},
    "group": ""
   },
   "4": {
    "id": 4,
    "rule_key": "PLATFORM-CLOCK-DOMAINS-01",
    "examples": {
     "uri": [
      {
       "link_text": "automatic frequency scaling",
       "url": {
        "scheme": "HTTPS",
        "host": "www.xilinx.com",
        "port": 0,
        "path": "/cgi-bin/docs/rdoc?t=vitis+guidance;v=2022.1;d=PLATFORM-CLOCK-DOMAINS-01.html",
        "query": "",
        "fragment": "",
        "media_type": "",
        "encoding": "",
        "data": ""
       },
       "docgen_filename": ""
      }
     ]
    },
    "build_target": "",
    "expects": "= or \u003e",
    "details": {
     "text": "The compiler selected the following frequencies for the runtime controllable kernel clock(s) and scalable system clock(s): \nKernel: blp_s_aclk_kernel_01 = 500.0 MHz \nKernel: blp_s_aclk_kernel_00 = 300.0 MHz \nScalable clock blp_s_aclk_kernel_01 (Id = 1) is used for rtl kernels. This design has 0 rtl kernel(s).\nScalable clock blp_s_aclk_kernel_00 (Id = 0) is used for hls kernels. This design has 2 hls kernel(s).",
     "args": {
      "arg": [
       {
        "string_val": "\nKernel: blp_s_aclk_kernel_01 = 500.0 MHz \nKernel: blp_s_aclk_kernel_00 = 300.0 MHz \nScalable clock blp_s_aclk_kernel_01 (Id = 1) is used for rtl kernels. This design has 0 rtl kernel(s).\nScalable clock blp_s_aclk_kernel_00 (Id = 0) is used for hls kernels. This design has 2 hls kernel(s)."
       }
      ]
     }
    },
    "resolution": {
     "text": "The !URI%1! feature allows user kernels to operate in hardware, even if at a lower frequency than intended."
    },
    "categories": {
     "2": "Performance",
     "0": "Accelerator",
     "1": "System"
    },
    "extended_categories": {},
    "group": ""
   }
  }
 },
 "specs_violated": {
  "hashmap": {
   "AUTO-FREQ-SCALING-08": {
    "key": "AUTO-FREQ-SCALING-08",
    "full_name": "Auto frequency scaling - Higher frequency possible",
    "owner": "sdx",
    "raw_msg": "For clock %REF, the auto scaled frequency %s MHz exceeds the original specified frequency. The compiler will select the original specified frequency of %s MHz.",
    "msg_abbrev": "",
    "msg_id": "0",
    "categories": {
     "1": "xclbin",
     "2": "Performance",
     "0": "Accelerator"
    },
    "resolution_msg": "The automatic frequency scaling feature allows user kernels to operate in hardware, even if at a lower frequency than intended. In this case the clock may in fact be able to run at a higher frequency than specified. You may want to consider !URI%1! the clock frequency higher for better performance. The '--kernel_frequency' option is one way to control the frequency specification.",
    "examples": {
     "uri": [
      {
       "link_text": "setting",
       "url": {
        "scheme": "HTTPS",
        "host": "www.xilinx.com",
        "port": 0,
        "path": "/cgi-bin/docs/rdoc?t=vitis+guidance;v=2022.1;d=AUTO-FREQ-SCALING-08.html",
        "query": "",
        "fragment": "",
        "media_type": "",
        "encoding": "",
        "data": ""
       },
       "docgen_filename": ""
      }
     ]
    },
    "severity": "SEV_ADVISORY",
    "disposition": "ENABLED",
    "expects": "",
    "affirm_msg": "",
    "dynamic_categories": {
     "0": false,
     "1": true,
     "2": false
    },
    "extensible_categories": [],
    "impact": "IMPACT_UNKNOWN",
    "group": ""
   },
   "ACCELERATOR-FIT-02": {
    "key": "ACCELERATOR-FIT-02",
    "full_name": "Accelerator fit - BlockRAM resources",
    "owner": "sdx",
    "raw_msg": "The design requires more BlockRAM resources than are available. The total number of BlockRAM elements required by all kernels is %f, out of %f available (utilization threshold %f). ",
    "msg_abbrev": "",
    "msg_id": "0",
    "categories": {
     "0": "Accelerator",
     "1": "Kernel",
     "2": "Resource",
     "3": "Local Memory"
    },
    "resolution_msg": "A BlockRAM is an internal memory resource that can be configured in a variety of sizes. Almost every design built within an FPGA requires the use of internal memory resources of some size for storage of coefficients, buffering of data, and a variety of other uses. !URI%1! describes ways to reduce the number of required BlockRAM resources.",
    "examples": {
     "uri": [
      {
       "link_text": "This page",
       "url": {
        "scheme": "HTTPS",
        "host": "www.xilinx.com",
        "port": 0,
        "path": "/cgi-bin/docs/rdoc?t=vitis+guidance;v=2022.1;d=ACCELERATOR-FIT-02.html",
        "query": "",
        "fragment": "",
        "media_type": "",
        "encoding": "",
        "data": ""
       },
       "docgen_filename": ""
      }
     ]
    },
    "severity": "SEV_CRITICAL_WARNING",
    "disposition": "ENABLED",
    "expects": "",
    "affirm_msg": "",
    "dynamic_categories": {
     "2": false,
     "3": false,
     "0": false,
     "1": false
    },
    "extensible_categories": [],
    "impact": "IMPACT_UNKNOWN",
    "group": ""
   }
  }
 },
 "specs_affirmed": {
  "hashmap": {
   "SYSLINK-1": {
    "key": "SYSLINK-1",
    "full_name": "system_link Top Level BD Creation",
    "owner": "system_link",
    "raw_msg": "Created top level block diagram design %STR",
    "msg_abbrev": "",
    "msg_id": "0",
    "categories": {},
    "resolution_msg": "",
    "severity": "SEV_FATAL",
    "disposition": "ENABLED",
    "expects": "",
    "affirm_msg": "",
    "dynamic_categories": {},
    "extensible_categories": [],
    "impact": "IMPACT_UNKNOWN",
    "group": ""
   },
   "PLATFORM-CLOCK-DOMAINS-01": {
    "key": "PLATFORM-CLOCK-DOMAINS-01",
    "full_name": "Runtime controllable clock domains - Achieved clock frequency (MHz)",
    "owner": "sdx",
    "raw_msg": "One or more clocks failed a timing check.",
    "msg_abbrev": "",
    "msg_id": "0",
    "categories": {
     "0": "Accelerator",
     "1": "System",
     "2": "Performance"
    },
    "resolution_msg": "The !URI%1! feature allows user kernels to operate in hardware, even if at a lower frequency than intended.",
    "examples": {
     "uri": [
      {
       "link_text": "automatic frequency scaling",
       "url": {
        "scheme": "HTTPS",
        "host": "www.xilinx.com",
        "port": 0,
        "path": "/cgi-bin/docs/rdoc?t=vitis+guidance;v=2022.1;d=PLATFORM-CLOCK-DOMAINS-01.html",
        "query": "",
        "fragment": "",
        "media_type": "",
        "encoding": "",
        "data": ""
       },
       "docgen_filename": ""
      }
     ]
    },
    "severity": "SEV_WARNING",
    "disposition": "ENABLED",
    "expects": "= or \u003e",
    "affirm_msg": "The compiler selected the following frequencies for the runtime controllable kernel clock(s) and scalable system clock(s): %s",
    "description": {
     "scheme": "DATA",
     "host": "",
     "port": 0,
     "path": "",
     "query": "",
     "fragment": "",
     "media_type": "text/html",
     "encoding": "charset=UTF-8",
     "data": "\u003chtml\u003e Kernel clocks (and system clocks for some platforms) are scalable; they can preserve functionality at the cost of performance by running at a lower frequency than requested. To be scalable, a clock must be driven by an MMCM where the control registers for the MMCM can be set by the runtime over AXI4-Lite. This item shows the final runtime controlled frequencies for the scalable clocks.\u003c/html\u003e"
    },
    "dynamic_categories": {
     "0": false,
     "1": false,
     "2": false
    },
    "extensible_categories": [],
    "impact": "IMPACT_UNKNOWN",
    "group": ""
   }
  }
 }
}

